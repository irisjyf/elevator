C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\04_bin\MainCtrl\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2) OBJECT(..\04_
                    -bin\MainCtrl\main.obj)

line level    source

   1          
   2          /*********************************************************/
   3          //Í·ÎÄ¼þ
   4          #include <intrins.h>
   5          #include <string.h>
   6          #include "STC15Fxxxx.h"
   7          #include "Time.h"
   8          #include "EEPROM.h"
   9          #include "74HC595.H"
  10          #include "HYM8563.H"
  11          #include "mfrc522.h"
  12          
  13          #define  BUFINLEN 50
  14          sbit LED  = P2^2;
  15          sbit fmq = P0^7;
  16          sbit bt0  = P0^1;
  17          sbit bt1  = P0^0;
  18          sbit bt2  = P4^6;
  19          sbit bt3  = P4^5;
  20          sbit bt4  = P2^7;
  21          sbit bt5  = P2^6;
  22          sbit bt6  = P2^5;
  23          sbit bt7  = P2^4;
  24          //#define FOSC  11059200L
  25          #define FOSC  24000000L
  26          
  27          #define BAUD  9600
  28          #define TM  (65536-(FOSC/4/BAUD))
  29          
  30          #define RESET_PIN P13
  31          
  32          #define LEDON {LED = 0;}
  33          #define LEDOFF {LED = 1;}
  34          #define TIMEOUT           -1
  35          #define TIMEOUT_ALL           5
  36          #define CC1101            0x00
  37          #define BT_UART           0x01
  38          #define MSG_OPEN          0x01
  39          #define MSG_CLOSE         0x02
  40          #define MSG_OBTAIN_STATUS 0x03
  41          #define FMQON   {P0M0 |= 0x80;P0M1 &= 0x7F;}
  42          #define FMQOFF  {P0M0 |= 0x80;P0M1 |= 0x80;}
  43          
  44          #define LEDCARD_ON {P15 = 0;}
  45          #define LEDCARD_OFF {P15 = 1;}
  46          
  47          
  48          #define COUNTLIMIT        0x01
  49          #define DATELIMIT         0x02
  50          
  51          #define TYPE_CARD_CUSTMER 0x01
  52          #define TYPE_CARD_MGR   0x02
  53          #define TYPE_CARD_FUNC    0x03
  54          
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 2   

  55          
  56          #define FUNC_TYPE_FORBIDEN    0x01
  57          #define FUNC_TYPE_CHECK_TIME  0x02
  58          #define FUNC_TYPE_SWITCH    0x03
  59          #define FUNC_TYPE_OFFSET    0x04
  60          #define FUNC_TYPE_AGENT     0x05
  61          #define FUNC_TYPE_Check     0x06
  62          #define FUNC_TYPE_CLEARBLACKLIST    0x07
  63          #define FUNC_TYPE_ENABLECOUNTER   0x08
  64          #define FUNC_TYPE_DISABLECOUNTER  0x09
  65          
  66          
  67          uchar xdata sendnum;
  68          uchar xdata cardtyp[2];
  69          uchar xdata cardnum[4];
  70          uchar xdata cardsize[1];
  71          uchar xdata cardkey[6] = {0xff,0xff,0xff,0xff,0xff,0xff};//
  72          uchar xdata newkey[16] = {0xff,0xff,0xff,0xff,0xff,0xff,0xFF,0x07,0x80,0x69,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}
             -;
  73          uchar xdata card_new_key[16] = {0xff,0xff,0xff,0xff,0xff,0xff,0xFF,0x07,0x80,0x69,0xFF,0xFF,0xFF,0xFF,0xFF
             -,0xFF};
  74            
  75          uchar xdata cardknum[16];
  76          uchar xdata cardwdata[16] = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x10,0x11,0x12,0x13,0x17,0x15,0x
             -16};
  77          //uchar xdata cardwdata[16] = {0xff,0xff,0xff,0xff,0xff,0xff,0xFF,0x07,0x80,0x69,0xFF,0xFF,0xFF,0xFF,0xFF,
             -0xFF};
  78          uchar code ENABLEALL[8] = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};
  79          uchar code a[8] = {0,0,0,0,0x00,0x00,0x00,0x00};
  80          uchar code b[8] = {0,0,0x00,0x00,0x00,0x00,0x00,0x00};
  81          uchar code c[8] = {255,255,255,255,255,255,255,255};
  82          uchar xdata Password_Data[4] = {0xff,0xff,0xff,0xff};
  83          uchar xdata Agent_Data[4] = {0xff,0xff,0xff,0xff};
  84          
  85          uchar xdata timere = 0;
  86          uchar xdata timecard = 510;
  87          uchar xdata *p;
  88          char xdata cardtypstu;
  89          char xdata cardnumstu;
  90          char xdata cardsizestu;
  91          char xdata cardcheckstu;
  92          char xdata cardknumstu;
  93          char xdata cardwdatastu;
  94          uchar xdata bufini = 0,bufino;
  95          uchar xdata maincmd[BUFINLEN];
  96          uchar xdata g_chOffset = 0;
  97          ulong xdata g_ulAgentID = 0;
  98          
  99          uchar xdata bt_data[BUFINLEN];
 100          uint  idata counter2 = 0;
 101          
 102          bit  idata internal2 = 0;
 103          uchar xdata g_ucPackageFlag = 0;
 104          uchar xdata g_ucEnableFlag = 0;
 105          uchar xdata g_chPasswordFlag = 0;
 106          uchar xdata g_ucAgentVerifyFlag = DIS_VERIFY_AGENT;
 107          uchar xdata g_ucReverseFlag = DIS_REVERSE;
 108          uchar xdata g_ucElevatorID = 0;
 109          uchar xdata g_ucEnableSwitch = 0;
 110          uchar xdata g_ucDisCounter = 0;
 111          uchar xdata tmElevator[7] = {0};
 112          
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 3   

 113          
 114          
 115          uchar *pp2;
 116          uchar xdata bt_buf[BUFINLEN];
 117          
 118          
 119          char IsReset(void)
 120          {
 121   1        uchar chData = 0;
 122   1        uchar uData2 = 0;
 123   1        chData = P1;
 124   1        
 125   1        if( (chData | 0xEF) == 0xEF)
 126   1        {
 127   2          delay_10ms(100);
 128   2          chData |= P1;
 129   2          delay_10ms(100);
 130   2          chData |= P1;
 131   2          delay_10ms(100);
 132   2          chData |= P1;
 133   2          delay_10ms(100);
 134   2          chData |= P1;
 135   2          delay_10ms(100);  
 136   2          chData |= P1;
 137   2          if((chData | 0xEF) == 0xEF)
 138   2            return TRUE;
 139   2        }
 140   1        return FALSE;
 141   1      }
 142          
 143          
 144          uchar IsDisableOutput(void)
 145          {
 146   1        uchar chData = 0;
 147   1        uchar uData2 = 0;
 148   1        chData = P1;
 149   1        
 150   1        if( (chData | 0xF7) == 0xF7)
 151   1        {
 152   2          delay_10ms(100);
 153   2          chData |= P1;
 154   2          if((chData | 0xF7) == 0xF7)
 155   2            return TRUE;
 156   2        }
 157   1        return FALSE;
 158   1      }
 159          
 160          
 161          void UART_init (void)
 162          {
 163   1        //EA  =  1; //ÔÊÐí×ÜÖÐ¶Ï£¨Èç²»Ê¹ÓÃÖÐ¶Ï£¬¿ÉÓÃ//ÆÁ±Î£©
 164   1      
 165   1        SCON = 0x50;
 166   1        //  S2CON = 0x50;     //8Î»Êý¾Ý,¿É±ä²¨ÌØÂÊ
 167   1        //  AUXR | =  0x04;   //¶¨Ê±Æ÷2Ê±ÖÓÎªFosc,¼´1T
 168   1        T2L  =  TM;   //Éè¶¨¶¨Ê±³õÖµ
 169   1        T2H  =  TM>>8;    //Éè¶¨¶¨Ê±³õÖµ
 170   1        //RL_T2H = 0XAA;
 171   1        //RL_T2L = 0XFA;
 172   1        AUXR |=  0x01;    //´®¿Ú1Ñ¡Ôñ¶¨Ê±Æ÷2Îª²¨ÌØÂÊ·¢ÉúÆ÷
 173   1        //  AUXR | =  0x10;   //Æô¶¯¶¨Ê±Æ÷2 
 174   1        //   IE2 | =  1; //ÔÊÐíUART2´®¿ÚµÄÖÐ¶Ï
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 4   

 175   1        ES  =  1; //ÔÊÐíUART1´®¿ÚµÄÖÐ¶Ï
 176   1      }
 177          
 178          void Send(uchar *str,uint len)
 179          {
 180   1        pp2 = str;
 181   1        counter2 = len;
 182   1        internal2 = 1;
 183   1        SBUF = *pp2++;
 184   1        while(internal2); 
 185   1      }
 186          uchar GetCommand(uchar chType, uchar*bufino, uchar bufini)
 187          {
 188   1        uchar xdata *combuf,*dat;
 189   1        uchar  i,j,len2,k;
 190   1        uint crc;
 191   1      
 192   1        if(chType == BT_UART)
 193   1        {
 194   2          combuf = bt_buf;
 195   2          dat = bt_data; 
 196   2        }
 197   1        i = *bufino;
 198   1      rescan1:
 199   1        if(bufini == i) 
 200   1          return 0;
 201   1      
 202   1        if((combuf[i++]) != 0xef) 
 203   1        {
 204   2          if(i >= BUFINLEN) i = 0;  
 205   2          *bufino = i; 
 206   2          goto rescan1;
 207   2        }
 208   1      
 209   1        if(i >= BUFINLEN) 
 210   1          i = 0;
 211   1      
 212   1        if(bufini == i) 
 213   1          return 0;
 214   1      
 215   1        if((combuf[i++]) != 0x01) 
 216   1        {
 217   2          if(i >= BUFINLEN) i = 0;  
 218   2          *bufino = i; 
 219   2          goto rescan1;
 220   2        }
 221   1        if(i >= BUFINLEN) 
 222   1          i = 0;
 223   1        if(bufini == i) 
 224   1          return 0;
 225   1      
 226   1        g_ucPackageFlag = combuf[i++];
 227   1      
 228   1        if(i >= BUFINLEN) 
 229   1          i = 0;
 230   1        if(bufini == i) 
 231   1          return 0;
 232   1      
 233   1        i++; 
 234   1      
 235   1        if(i >= BUFINLEN) 
 236   1          i = 0;
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 5   

 237   1        if(bufini == i) 
 238   1          return 0;
 239   1      
 240   1        len2 = combuf[i++]; 
 241   1        if(i >= BUFINLEN) 
 242   1          i = 0;
 243   1        if(bufini == i) 
 244   1          return 0;
 245   1      
 246   1        //  len0 = len1*256+len2;
 247   1        if(len2 <= 2 || len2 >= 200) {
 248   2          *bufino = i; 
 249   2          goto rescan1;
 250   2        } 
 251   1      
 252   1        crc = g_ucPackageFlag+len2;
 253   1        j = 0;
 254   1      
 255   1        while(len2-2)
 256   1        {
 257   2          if(bufini == i) 
 258   2            return 0;
 259   2          k = dat[j++] = combuf[i++];
 260   2      
 261   2          if(i >= BUFINLEN) 
 262   2            i = 0;
 263   2          crc += k;
 264   2      
 265   2          len2--;
 266   2        }
 267   1      
 268   1        if(bufini == i) 
 269   1          return 0;
 270   1      
 271   1        crc -= (unsigned int)combuf[i++]*256;
 272   1      
 273   1        if(i >= BUFINLEN) 
 274   1          i = 0;
 275   1      
 276   1        if(bufini == i) 
 277   1          return 0;
 278   1      
 279   1        crc -= combuf[i++];
 280   1      
 281   1        if(i >= BUFINLEN) 
 282   1          i = 0;
 283   1      
 284   1        if(crc) 
 285   1        {
 286   2          *bufino = i; 
 287   2          goto rescan1;
 288   2        }
 289   1        else 
 290   1        {
 291   2          *bufino = i; 
 292   2          return 1;
 293   2        }
 294   1      }
 295          
 296          
 297          void Make(uchar bbs,unsigned int len,uchar *sendbao)
 298          {
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 6   

 299   1        uchar i;
 300   1        uint  sum;
 301   1      
 302   1        uchar xdata bao[80];
 303   1        sum = 0;
 304   1      
 305   1        for(i = 0;i<len-2;i++)
 306   1        {
 307   2          bao[i]  =  sendbao[i];
 308   2        }
 309   1        sendbao[0]  =  0xef;
 310   1        sendbao[1]  =  0x01;
 311   1      
 312   1        sendbao[2]  =  bbs;
 313   1        sendbao[3]  =  len/256;
 314   1        sendbao[4]  =  len%256;
 315   1      
 316   1        for(i  =  0;i<len-2;i++)
 317   1        {
 318   2          sendbao[5+i]  =  bao[i];
 319   2          sum  =  sum + bao[i];
 320   2        }
 321   1        sum = sum+len+bbs;
 322   1        sendbao[4+len-1] = sum/256;
 323   1        sendbao[4+len] = sum%256;
 324   1      }
 325          
 326          
 327          void memcopy(uchar *des,uchar *src,uchar len)
 328          {
 329   1        uchar i ;
 330   1        for(i = 0;i<len;i++)
 331   1        {
 332   2          *des++ = *src++;
 333   2        }
 334   1        if(len<16)
 335   1        {
 336   2          for(i = len;i<16;i++)
 337   2            *des = 0;
 338   2        }
 339   1      } 
 340          
 341          
 342          
 343          uchar GetElevatorID()
 344          {
 345   1        uchar dat = 0;
 346   1        dat |= (uchar)bt7;
 347   1        dat <<= 1;
 348   1        dat |= (uchar)bt6;
 349   1        dat <<= 1;
 350   1        dat |= (uchar)bt5;
 351   1        dat <<= 1;
 352   1        dat |= (uchar)bt4;
 353   1        dat <<= 1;
 354   1        dat |= (uchar)bt3;
 355   1        dat <<= 1;
 356   1        dat |= (uchar)bt2;
 357   1        dat <<= 1;
 358   1        dat |= (uchar)bt1;
 359   1        dat <<= 1;
 360   1        dat |= (uchar)bt0;
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 7   

 361   1        return dat;
 362   1      }
 363          
 364          uchar ConfirmByte(uchar dat)
 365          {
 366   1        uchar  i = 0;
 367   1        uchar  temp = dat;
 368   1        uchar  count = 0;
 369   1        for(i = 0;i<8;i++)
 370   1        {
 371   2          if(temp&0x80)
 372   2          {
 373   3            count++;
 374   3          }
 375   2          temp <<= 1;
 376   2        }
 377   1        return count;
 378   1      }
 379          bit ConfirmSingleOrMulti(uchar *dat)
 380          {
 381   1        uchar  i = 0;
 382   1        uchar  count = 0;
 383   1        for(i = 0;i<8;i++)
 384   1        {
 385   2          count += ConfirmByte(dat[i]); 
 386   2        }
 387   1        if(count>2)
 388   1          return 1;
 389   1        else
 390   1          return 0;
 391   1      }
 392          
 393          
 394          uchar ReadFuntionCard(uchar chOffset)
 395          { 
 396   1        uchar temp[16];
 397   1        if(MI_RD_OK != readDataFromIc(cardkey,SECTION_0 + chOffset,temp))
 398   1          return Do_False;
 399   1      
 400   1        memcopy(maincmd+2,temp,11);
 401   1        if(MI_RD_OK != readDataFromIc(cardkey,SECTION_1 + chOffset,temp))
 402   1          return Do_False;
 403   1      
 404   1        memcopy(maincmd+13,temp,12);
 405   1        if(MI_RD_OK != readDataFromIc(cardkey,SECTION_2 + chOffset,temp))
 406   1          return Do_False;
 407   1      
 408   1        memcopy(maincmd+25,temp,2);
 409   1        if(MI_RD_OK != readDataFromIc(cardkey,SECTION_3 + chOffset,temp))
 410   1          return Do_False;
 411   1      
 412   1        memcopy(maincmd+27,temp,1);
 413   1        if(MI_RD_OK != readDataFromIc(cardkey,SECTION_4 + chOffset,temp))
 414   1          return Do_False;
 415   1      
 416   1        memcopy(maincmd+28,temp,16);
 417   1        if(MI_RD_OK != readDataFromIc(cardkey,SECTION_5 + chOffset,temp))
 418   1          return Do_False;
 419   1      
 420   1        memcopy(maincmd+44,temp,16);
 421   1        if(MI_RD_OK != readDataFromIc(cardkey,SECTION_6 + chOffset,temp))
 422   1          return Do_False;
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 8   

 423   1      
 424   1        memcopy(maincmd+60,temp,8);
 425   1        if(MI_RD_OK != readDataFromIc(cardkey,SECTION_7 + chOffset,temp))
 426   1          return Do_False;
 427   1        memcopy(maincmd+68,temp,5);
 428   1        return Do_True;
 429   1      }
 430          
 431          
 432          unsigned WriteFunctionCard(uchar chOffset)
 433          {
 434   1        uchar  temp[16];
 435   1        memcopy(temp,bt_data+1,11); 
 436   1        if(writeDataToIc(cardkey,SECTION_0 + chOffset,temp)  !=  MI_WR_OK)  
 437   1          return Do_False;
 438   1        memcopy(temp,bt_data+12,12);
 439   1        if(writeDataToIc(cardkey,SECTION_1 + chOffset,temp)  !=  MI_WR_OK)
 440   1          return Do_False;
 441   1        memcopy(temp,bt_data+24,2);
 442   1        if(writeDataToIc(cardkey,SECTION_2 + chOffset,temp)  !=  MI_WR_OK)
 443   1          return Do_False;
 444   1        memcopy(temp,bt_data+26,1);
 445   1        if(writeDataToIc(cardkey,SECTION_3 + chOffset,temp)  !=  MI_WR_OK)
 446   1          return Do_False;
 447   1        memcopy(temp,bt_data+27,16);
 448   1        if(writeDataToIc(cardkey,SECTION_4 + chOffset,temp)  !=  MI_WR_OK)
 449   1          return Do_False;
 450   1        memcopy(temp,bt_data+43,16);
 451   1        if(writeDataToIc(cardkey,SECTION_5 + chOffset,temp)  !=  MI_WR_OK)
 452   1          return Do_False;
 453   1        memcopy(temp,bt_data+59,8);
 454   1        if(writeDataToIc(cardkey,SECTION_6 + chOffset,temp)  !=  MI_WR_OK)
 455   1          return Do_False;
 456   1        memcopy(temp,bt_data+67,5);
 457   1        if(writeDataToIc(cardkey,SECTION_7 + chOffset,temp)  !=  MI_WR_OK)
 458   1          return Do_False;
 459   1        return  Do_True;
 460   1      }
 461          
 462          
 463          
 464          uchar ReverseWriteData2Card(uchar ucData)
 465          {
 466   1        uchar xdata temp[16];
 467   1        uchar  ucSectionIndex = 0;
 468   1        uchar  ucOffset = 0;
 469   1        
 470   1        ucSectionIndex = g_ucElevatorID >> 4;
 471   1        ucOffset = g_ucElevatorID & 0x0F;
 472   1      
 473   1        if(MI_RD_OK  !=  readDataFromIc(cardkey,SECTION_7 + ucSectionIndex,temp))
 474   1          return Do_False;
 475   1        
 476   1        temp[ucOffset] = ucData; //¼ÇÂ¼Ð¡Ê±
 477   1        
 478   1        if(MI_WR_OK != writeDataToIc(cardkey,SECTION_7 + ucSectionIndex,temp))
 479   1          return Do_False;
 480   1        
 481   1        return  Do_True;
 482   1      }
 483          
 484          
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 9   

 485          uchar ReadCardReverseData(uchar* pucData)
 486          {
 487   1        //uchar xdata ucElevatorID = 0;
 488   1        uchar xdata temp[16];
 489   1        //uchar xdata ucTimes[7];
 490   1        uchar  ucSectionIndex = 0;
 491   1        uchar  ucOffset = 0;
 492   1        
 493   1        //ucElevatorID = GetElevatorID();
 494   1        
 495   1        //readtime(ucTimes);
 496   1        
 497   1      //  ucSectionIndex = ucElevatorID / 16;
 498   1      //  ucOffset = ucElevatorID % 16;
 499   1      
 500   1        ucSectionIndex = g_ucElevatorID >> 4;
 501   1        ucOffset = g_ucElevatorID & 0xF;
 502   1      
 503   1        if(MI_RD_OK  !=  readDataFromIc(cardkey,SECTION_7 + ucSectionIndex,temp))
 504   1            return Do_False;
 505   1          
 506   1        *pucData = temp[ucOffset];
 507   1          
 508   1        return  Do_True;
 509   1      }
 510          
 511          
 512          char ReadUserCard(uchar chOffset)
 513          {
 514   1        uchar temp[16];
 515   1        if(MI_RD_OK  !=  readDataFromIc(cardkey,SECTION_0 + chOffset,temp))
 516   1          return Do_False;
 517   1        memcopy(maincmd + 2, temp, 11);
 518   1        if(MI_RD_OK  !=  readDataFromIc(cardkey,SECTION_1 + chOffset,temp))
 519   1          return Do_False;
 520   1        memcopy(maincmd + 13, temp, 12);
 521   1        if(MI_RD_OK  !=  readDataFromIc(cardkey,SECTION_2 + chOffset,temp))
 522   1          return Do_False;
 523   1        memcopy(maincmd + 25, temp, 2);
 524   1        if(MI_RD_OK  !=  readDataFromIc(cardkey,SECTION_3 + chOffset,temp))
 525   1          return Do_False;
 526   1        memcopy(maincmd + 27, temp, 9);
 527   1        if(MI_RD_OK  !=  readDataFromIc(cardkey,SECTION_4 + chOffset,temp))
 528   1          return Do_False;
 529   1        memcopy(maincmd + 36, temp, 9);
 530   1        if(MI_RD_OK  !=  readDataFromIc(cardkey,SECTION_5 + chOffset,temp))
 531   1          return Do_False;
 532   1        memcopy(maincmd + 45, temp, 9);
 533   1      
 534   1        if(MI_RD_OK  !=  readDataFromIc(cardkey,SECTION_6 + chOffset,temp))
 535   1          return Do_False;
 536   1        memcopy(maincmd + 53, temp, 13);
 537   1        //errOkFlag = 1;
 538   1        return Do_True;
 539   1      }
 540          
 541          uchar WriteUserCard( uchar chOffset)
 542          { 
 543   1        uchar temp[16];
 544   1        memcopy(temp,bt_data+1,11); 
 545   1        if(writeDataToIc(cardkey,SECTION_0 + chOffset,temp) != MI_WR_OK)  
 546   1          return Do_False;
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 10  

 547   1      
 548   1        memcopy(temp,bt_data+12,12);
 549   1        if(writeDataToIc(cardkey,SECTION_1 + chOffset,temp) != MI_WR_OK)
 550   1          return Do_False;
 551   1      
 552   1        memcopy(temp,bt_data+24,2);
 553   1        if(writeDataToIc(cardkey,SECTION_2 + chOffset,temp) != MI_WR_OK)
 554   1          return Do_False;
 555   1      
 556   1        memcopy(temp,bt_data+26,9);
 557   1        if(writeDataToIc(cardkey,SECTION_3 + chOffset,temp) != MI_WR_OK)
 558   1          return Do_False;
 559   1      
 560   1        memcopy(temp,bt_data+35,9);
 561   1        if(writeDataToIc(cardkey,SECTION_4 + chOffset,temp) != MI_WR_OK)
 562   1          return Do_False;
 563   1      
 564   1        memcopy(temp,bt_data+44,9);
 565   1        if(writeDataToIc(cardkey,SECTION_5 + chOffset,temp) != MI_WR_OK)
 566   1          return Do_False;
 567   1      
 568   1        memcopy(temp,bt_data+53,13);
 569   1        if(writeDataToIc(cardkey,SECTION_6 + chOffset,temp) != MI_WR_OK)
 570   1          return Do_False;
 571   1        return  Do_True;
 572   1      }
 573          
 574          
 575          uchar RecordInterParam(uchar chOffset)
 576          { 
 577   1        uchar temp[16];
 578   1        uchar xdata tmData[7];
 579   1        //Êý¾ÝÆ«ÒÆÁ¿
 580   1        temp[0] = chOffset;
 581   1        //ÆôÓÃ´úÀíÉÌ¼ìÑé
 582   1        temp[1] = ReadAgentFlagData();
 583   1      
 584   1        //´úÀíÉÌID
 585   1        temp[2] = (g_ulAgentID >> 24) & 0xFF;
 586   1        temp[3] = (g_ulAgentID >> 16) & 0xFF;
 587   1        temp[4] = (g_ulAgentID >> 8) & 0xFF;
 588   1        temp[5] = g_ulAgentID & 0xFF;
 589   1      
 590   1        //µçÌÝºÅ
 591   1        temp[6] = GetElevatorID();
 592   1        //µçÌÝÊ±¼ä
 593   1        readtime(tmData);
 594   1        temp[7] = tmData[0];
 595   1        temp[8] = tmData[1];
 596   1        temp[9] = tmData[2];
 597   1        temp[10] = tmData[3];
 598   1        temp[11] = tmData[4];
 599   1        temp[12] = tmData[5];
 600   1        temp[13] = tmData[6];
 601   1        
 602   1        temp[14] = ReadReverseCheckFlag();
 603   1        
 604   1        if(writeDataToIc(cardkey,SECTION_16,temp) != MI_WR_OK)  
 605   1          return Do_False;
 606   1      
 607   1        memset(temp, 0, 16);
 608   1        temp[0] = Password_Data[0];
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 11  

 609   1        temp[1] = Password_Data[1];
 610   1        temp[2] = Password_Data[2];
 611   1        temp[3] = Password_Data[3];
 612   1        
 613   1        if(writeDataToIc(cardkey,SECTION_16 + 1,temp) != MI_WR_OK)  
 614   1          return Do_False;
 615   1        
 616   1        maincmd[0] = tmData[0];
 617   1        maincmd[1] = tmData[1];
 618   1        maincmd[2] = tmData[2];
 619   1        maincmd[3] = tmData[3];
 620   1        maincmd[4] = tmData[4];
 621   1        maincmd[5] = tmData[5];
 622   1        maincmd[6] = tmData[6];
 623   1      
 624   1        Make(0xFD, 9, maincmd);
 625   1        Send(maincmd, 14);
 626   1      
 627   1        return  Do_True;
 628   1      }
 629          
 630          void ScanCommand()
 631          {
 632   1        uchar i = 0,j = 0;
 633   1        uchar errOkFlag = 0;
 634   1        //uchar xdata temp[16];
 635   1        if(bufini != bufino) 
 636   1        {
 637   2          if(Do_True == GetCommand(BT_UART,&bufino,bufini))
 638   2          {
 639   3            switch(g_ucPackageFlag)
 640   3            {
 641   4            case(1)://Ð´
 642   4              if(bt_data[0] == 0x02)
 643   4              {
 644   5                j = 0;
 645   5                maincmd[0] = 0;
 646   5                for(i = 0;i<16;i++)
 647   5                { 
 648   6                  maincmd[i+1] = 0;
 649   6                  if(writePassword(cardkey,i,newkey) != MI_WR_OK)
 650   6                  {
 651   7                    maincmd[i+1] = 1;
 652   7                    maincmd[0] = 1;
 653   7                  }
 654   6                  //break;
 655   6                }
 656   5                //maincmd[0] = 1;
 657   5                Make(1,19,maincmd);
 658   5                Send(maincmd,24);
 659   5              }
 660   4              break;
 661   4            case(2):         //¶Á
 662   4              for(i = 0;i<47;i++)
 663   4              {
 664   5                if(MI_RD_OK == readDataFromIc(cardkey,i,cardknum))
 665   5                { 
 666   6                  Send(cardknum,16);
 667   6                } 
 668   5              }
 669   4              break;
 670   4            case(3):    //ÉÏÎ»»úÐ´ÒµÖ÷¿¨ÐÅÏ¢
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 12  

 671   4              errOkFlag = 0;
 672   4              if(bt_data[0] == 1)
 673   4              {
 674   5                errOkFlag  =  ReadUserCard(g_chOffset);
 675   5                if(errOkFlag == 1)
 676   5                  maincmd[0] = 0;
 677   5                else
 678   5                  maincmd[0] = 1;
 679   5                maincmd[1] = 1;
 680   5                Make(3,55,maincmd);
 681   5                Send(maincmd,60); 
 682   5              }
 683   4              if(bt_data[0] == 2)
 684   4              {
 685   5                errOkFlag  =  WriteUserCard(g_chOffset);
 686   5                if(errOkFlag == 1)
 687   5                  maincmd[0] = 0;
 688   5                else
 689   5                  maincmd[0] = 1;
 690   5                maincmd[1] = 2;
 691   5                Make(3,4,maincmd);
 692   5                Send(maincmd,9);
 693   5              }
 694   4              break;
 695   4            case(4):    //ÉÏÎ»»ú¶ÁÐ´¹ÜÀíÔ±¿¨
 696   4              errOkFlag = 0;
 697   4              if(bt_data[0] == 1)
 698   4              {
 699   5                errOkFlag  =  ReadUserCard(g_chOffset);
 700   5                  if(errOkFlag == 1)
 701   5                    maincmd[0] = 0;
 702   5                  else
 703   5                    maincmd[0] = 1;
 704   5                maincmd[1] = 1;
 705   5                Make(4,55,maincmd);
 706   5                Send(maincmd,60); 
 707   5              }
 708   4              if(bt_data[0] == 2)
 709   4              {
 710   5                errOkFlag  =  WriteUserCard(g_chOffset);
 711   5                if(errOkFlag == 1)                
 712   5                  maincmd[0] = 0;
 713   5                else
 714   5                  maincmd[0] = 1;
 715   5                maincmd[1] = 2;
 716   5                Make(4,4,maincmd);
 717   5                Send(maincmd,9);
 718   5              }
 719   4      
 720   4              break;
 721   4            case(5):    //ÉÏÎ»»ú¶ÁÐ´¹¦ÄÜ¿¨
 722   4              errOkFlag = 0;
 723   4              if(bt_data[0] == 1)//Ð´
 724   4              {
 725   5                errOkFlag  =  ReadFuntionCard(g_chOffset);
 726   5                if(errOkFlag == 1)
 727   5                  maincmd[0] = 0;
 728   5                else
 729   5                  maincmd[0] = 1;
 730   5                maincmd[1] = 1;
 731   5                Make(5,69,maincmd);
 732   5                Send(maincmd,74); 
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 13  

 733   5              }
 734   4              if(bt_data[0] == 2)//¶Á
 735   4              {
 736   5                errOkFlag  =  WriteFunctionCard(g_chOffset);
 737   5                if(errOkFlag == 1)                
 738   5                  maincmd[0] = 0;
 739   5                else
 740   5                  maincmd[0] = 1;
 741   5                maincmd[1] = 2;
 742   5                Make(5,4,maincmd);
 743   5                Send(maincmd,9);
 744   5              }
 745   4      
 746   4              break;
 747   4            case (7):
 748   4              maincmd[6] = bt_data[0];
 749   4              maincmd[5] = bt_data[1];
 750   4              maincmd[3] = bt_data[2];
 751   4              maincmd[2] = bt_data[3];
 752   4              maincmd[1] = bt_data[4];
 753   4              maincmd[0] = bt_data[5];
 754   4              maincmd[4] = bt_data[6];
 755   4              P8563_settime(maincmd);
 756   4              maincmd[0] = 0;
 757   4              Make(7,3,maincmd);
 758   4              Send(maincmd,8);
 759   4              break;
 760   4            case(8):    //
 761   4              readtime(maincmd);
 762   4              Make(8,9,maincmd) ;
 763   4              Send(maincmd,14);
 764   4              break;
 765   4            }
 766   3          }
 767   2        }
 768   1      } 
 769          
 770          void Beep(void)
 771          {
 772   1        uchar i;
 773   1        FMQON
 774   1        for(i = 0;i<100;i++)
 775   1          Delay1();
 776   1        FMQOFF
 777   1      }
 778          
 779          void LongBeep(void)
 780          {
 781   1        uchar i;  
 782   1        for(i = 0;i<100;i++)
 783   1            Delay1();
 784   1        FMQON
 785   1        for(i = 0;i<200;i++)
 786   1            Delay1();
 787   1        FMQOFF
 788   1      }
 789          
 790          
 791          /*
 792          * º¯Êý¹¦ÄÜ: ¶à´ÎÏìÉù
 793          *²ÎÊý:    
 794          *   uchar ucCount: ÏàÉù´ÎÊý
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 14  

 795          *
 796          *·µ»ØÖµ:ÎÞ
 797          *
 798          */
 799          
 800          void Sounds(uchar ucCount)
 801          {
 802   1        uchar i = 0;
 803   1        for(i=0; i < ucCount - 1; i++)
 804   1        {
 805   2          Beep();
 806   2          delay_10ms(30000);
 807   2        }
 808   1        Beep();
 809   1      }
 810          
 811          void flash(uchar ucCount)
 812          {
 813   1        uchar i;
 814   1        for(i=0; i < ucCount - 1; i++)
 815   1        {   
 816   2          LED = ~LED;
 817   2          delay_10ms(1200);
 818   2        }
 819   1        LEDON;
 820   1      }
 821          
 822          void PressButton(uchar *dat)
 823          {   
 824   1        uchar i;
 825   1        pressKey(dat);  
 826   1        //pressKey(0xff);
 827   1        for(i = 0;i<100;i++)
 828   1          Delay1();
 829   1        pressKey(b);
 830   1        //pressKey(0x00);
 831   1        //Beep();
 832   1      }
 833          
 834          
 835          //uchar GetVersion(uchar ucOffset)
 836          //{
 837          //  uchar ucRet = MI_ERR;
 838          //  memset(cardknum, 0, 16);
 839          //  //¶ÁÉú²úÊýÖµ
 840          //  ucRet = readDataFromIc(cardkey, SECTION_46 + ucOffset, cardknum);
 841          //  
 842          //  if(ucRet != MI_RD_OK)
 843          //    return 0;
 844          //  
 845          //  return cardknum[4];
 846          //}
 847          
 848          //uchar CheckSerial(uchar ucOffset)
 849          //{
 850          //  uchar ucRet = 0;
 851          //  uchar ucCardSerial[4];
 852          //  uchar ucTemp[16];
 853          
 854          //  ucRet = readDataFromIc(cardkey, SECTION_46 + ucOffset, ucTemp);
 855          //  if(MI_RD_OK != ucRet)
 856          //    return Do_False;
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 15  

 857          //    
 858          //  ucRet = PcdAnticoll(ucCardSerial);          //»ñÈ¡¿¨µÄ¿¨ºÅ
 859          //  
 860          //  if(ucRet != MI_OK)
 861          //    return Do_False;  
 862          //    
 863          //  if( ucTemp[5] == ucCardSerial[0]
 864          //    && ucTemp[6] == ucCardSerial[1]
 865          //    && ucTemp[7] == ucCardSerial[2]
 866          //    && ucTemp[8] == ucCardSerial[3]
 867          //    )
 868          //    return Do_True;
 869          //  return Do_False;
 870          
 871          //}
 872          
 873          //uchar WriteSerial()
 874          //{
 875          //  uchar ucRet = 0;
 876          //  uchar ucCardSerial[4];
 877          //  uchar ucTemp[16];
 878          
 879          //  ucRet = readDataFromIc(cardkey, SECTION_46, ucTemp);
 880          //  if(MI_RD_OK != ucRet)
 881          //    return Do_False;
 882          //    
 883          //  ucRet = PcdAnticoll(ucCardSerial);          //»ñÈ¡¿¨µÄ¿¨ºÅ
 884          //  
 885          //  if(ucRet != MI_OK)
 886          //    return Do_False;  
 887          //    
 888          //  ucTemp[4] = 0xA0;
 889          //  
 890          //  ucTemp[5] = ucCardSerial[0];
 891          //  ucTemp[6] = ucCardSerial[1];
 892          //  ucTemp[7] = ucCardSerial[2];
 893          //  ucTemp[8] = ucCardSerial[3];
 894          //  //Ð´Éú²úÊýÖµ
 895          //  ucRet = writeDataToIc(cardkey, SECTION_46, ucTemp);
 896          //  
 897          //  if(ucRet == MI_WR_OK)
 898          //    return Do_True;
 899          //  return Do_False;
 900          //}
 901          
 902          
 903          
 904          /*
 905            º¯Êý¹¦ÄÜ£º
 906            ²ÎÊý
 907            ·µ»ØÖµ£º
 908          */
 909          uchar DoBlackList(uchar iType, uchar *pData, uchar chLength)
 910          {
 911   1        uchar xdata i = 0;
 912   1        char xdata iCount  =  chLength / 4;
 913   1        
 914   1        for(i = 0; i<iCount; i++)
 915   1        {
 916   2          if(pData[i*4] != 0 || pData[i*4+1] != 0 || pData[i*4+2] != 0)
 917   2          {
 918   3            if(pData[i*4+3] == 0)
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 16  

 919   3              //deleteBlackList(iType, pData+i*4);
 920   3              DeleteBlackList(iType, pData+i*4);
 921   3            else
 922   3              //AddBlackList(iType, pData+i*4);
 923   3              Record2BlackList(iType, pData + i*4);
 924   3          }
 925   2      
 926   2          maincmd[0] = iType;
 927   2          maincmd[1] = pData[i*4];
 928   2          maincmd[2] = pData[i*4+1];
 929   2          maincmd[3] = pData[i*4+2];
 930   2          
 931   2          Make(0xFE, 6, maincmd);
 932   2          Send(maincmd, 11);
 933   2        }
 934   1        return 1;
 935   1      }
 936          
 937          /*
 938          *º¯Êý¹¦ÄÜ:
 939                ¼ì²éÊ¹ÓÃ´ÎÊý
 940          *²ÎÊý:
 941          *     char *pCount,·µ»ØÊ¹ÓÃ´ÎÊý
 942          *·µ»ØÖµ:
 943                Do_True:Ê¹ÓÃ´ÎÊýÔÚ·¶Î§ÄÚ
 944          *     Do_False:Ö´ÐÐ´íÎó»òÕßÊ¹ÓÃ´ÎÊýÒÑ¾­Îª0
 945          */
 946          uchar CheckUseCount(uint  *pCount, uchar  chOffset)
 947          {
 948   1        uchar xdata temp1[16];
 949   1        uint  leave_count = 0;
 950   1        
 951   1        if( MI_RD_OK != readDataFromIc(cardkey,SECTION_2 + chOffset,temp1) )
 952   1          return Do_False;
 953   1        
 954   1        leave_count = (temp1[0] << 8) + temp1[1] ;
 955   1        
 956   1        if(leave_count <= 0)
 957   1          return Do_False;
 958   1        
 959   1        if(g_ucDisCounter == ENABLE_COUNTER)
 960   1          leave_count--;
 961   1        
 962   1        temp1[0] = (leave_count >> 8) & 0xFF;
 963   1        temp1[1] = leave_count & 0xFF;
 964   1      
 965   1        writeDataToIc(cardkey,SECTION_2 + chOffset,temp1);
 966   1        *pCount = leave_count;
 967   1        
 968   1        return Do_True;
 969   1      }
 970          /*
 971            º¯Êý¹¦ÄÜ£º
 972            ²ÎÊý
 973            ·µ»ØÖµ£º
 974          */
 975          uchar DoFunctionEnableInfo(uchar chOffset)
 976          {
 977   1        uchar  temp1[16];
 978   1        uint  count  =  0;
 979   1        uchar  chType = 0;
 980   1        
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 17  

 981   1      //  if(Do_True != CheckUseCount( &count, 0 ))
 982   1      //    return Do_False;
 983   1      
 984   1        if( MI_RD_OK != readDataFromIc(cardkey,SECTION_3 + chOffset,temp1))
 985   1          return Do_False;
 986   1      
 987   1        chType = temp1[0];
 988   1        
 989   1      //  if(GetElevatorID() != temp1[0])  //ÊÇ±¾µçÌÝ
 990   1      //    return Do_False;
 991   1      
 992   1        if( MI_RD_OK != readDataFromIc(cardkey,SECTION_4 + chOffset,temp1))
 993   1          return Do_False;
 994   1        
 995   1        DoBlackList(chType, temp1, 16);
 996   1        
 997   1        if(MI_RD_OK != readDataFromIc(cardkey,SECTION_5 + chOffset,temp1))
 998   1          return Do_False;  
 999   1        DoBlackList(chType, temp1, 16);
1000   1      
1001   1        if(MI_RD_OK != readDataFromIc(cardkey,SECTION_6 + chOffset,temp1))
1002   1          return Do_False;
1003   1        DoBlackList(chType, temp1, 8);
1004   1      
1005   1        //Beep();
1006   1        return Do_True;
1007   1      }
1008          
1009          //²Ù×÷µçÌÝ°´Å¥
1010          void DealElevatorBtn(uchar p[])
1011          {   
1012   1        if(0==ConfirmSingleOrMulti(p + 1))
1013   1        {
1014   2          Beep();
1015   2          enableKey(p + 1);
1016   2          PressButton(p + 1);
1017   2        }
1018   1        else
1019   1        {
1020   2          enableKey(p + 1);
1021   2          //PcdHalt();
1022   2          Beep();
1023   2        }
1024   1      }
1025          //
1026          /*
1027          * º¯Êý¹¦ÄÜ: ´¦ÀíÉÈÇøÖÐÖ¸¶¨µÄµçÌÝ£¬²Ù×÷µçÌÝ°´Å¥
1028          *²ÎÊý:    
1029          *   uchar chIndex:  ÉÈÇø±àºÅ
1030          *·µ»ØÖµ:ÎÞ
1031          *
1032          */
1033          
1034          uchar DealElevatorIndex(uchar chIndex)
1035          {
1036   1        uchar xdata temp1[16];
1037   1        if( MI_RD_OK != readDataFromIc(cardkey, chIndex, temp1))
1038   1          return Do_False;
1039   1      
1040   1        //Æ¥ÅäµçÌÝºÅ
1041   1        if(GetElevatorID() != temp1[0])
1042   1          return Do_False;
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 18  

1043   1      
1044   1        //²Ù×÷µçÌÝ°´Å¥
1045   1        DealElevatorBtn(temp1);
1046   1      
1047   1      
1048   1        return Do_True;
1049   1      }
1050          
1051          
1052          /*
1053          * º¯Êý¹¦ÄÜ: ´¦ÀíµçÌÝ
1054          *²ÎÊý:    
1055          *   uchar nType:  1 : ²»Ö¸¶¨Â¥ÌÝ
1056          *         0 : Ö¸¶¨Â¥ÌÝ
1057          *·µ»ØÖµ:ÎÞ
1058          *
1059          */
1060          
1061          void DealElevator(uchar nType)
1062          {
1063   1        if(nType & 0x01==1) //²»Ö¸¶¨Â¥ÌÝ
1064   1        {   
1065   2          Sounds(1);
1066   2          enableKey(ENABLEALL); //Ê¹ÄÜ°´Å¥
1067   2        }
1068   1        else
1069   1        {
1070   2          DealElevatorIndex(SECTION_3 + g_chOffset);
1071   2          DealElevatorIndex(SECTION_4 + g_chOffset);
1072   2          DealElevatorIndex(SECTION_5 + g_chOffset);
1073   2          DealElevatorIndex(SECTION_6 + g_chOffset);
1074   2        }
1075   1      }
1076          
1077          //uchar WriteOffsetPsw(uchar* pdatas)
1078          //{
1079          //  if(Do_True != WriteOffset(pdatas[0]))
1080          //    return Do_False;
1081          //  if(Do_True != WriteSectionPsw(pdatas + 1))
1082          //    return Do_False;
1083          //  return Do_True;
1084          //}
1085          
1086          unsigned long GetCardAgentID(uchar ucOffset)
1087          {
1088   1        ulong xdata lAgentID = 0xffffffff;
1089   1        uchar xdata temp1[16];
1090   1        if(MI_RD_OK != readDataFromIc(cardkey,SECTION_46 + ucOffset,temp1))
1091   1          return Do_False;
1092   1        lAgentID = (temp1[0]<<24) + (temp1[1]<<16) + (temp1[2]<<8) + temp1[3];
1093   1        return lAgentID;
1094   1      }
1095          
1096          
1097          ///////////////////////////////////////////////////////////////////////////////////////
1098          ///////////
1099          /////////// ¼ÆËãÃ¿¸öÉÈÇøºÅÓë¿éºÅµÄ¶ÔÓ¦¹ØÏµ,±¾´¦ËùÓÃ·Ç¾ø¶Ô¶ÔµØÖ·¿é/////////////////////
1100          /////////// Èë¿Ú:  Ã¿¸öÉÈÇø¶ÔÓ¦µÄ¿éºÅ,·¶Î§:¿é0~¿é3
1101          //////////////////////////////////////////////////////////////////////////////////////
1102          
1103          
1104          uchar GeneratePsw()     //ÃÜÔ¿´¦Àíº¯Êý Ò»¿¨Ò»ÃÜÔ¿£¬²»Í¬ÉÈÇø²»ÃÜÔ¿Ò²²»Í¬
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 19  

1105          {
1106   1        uchar  i;
1107   1      
1108   1        for(i = 0; i < 4; i++)
1109   1          card_new_key[1 + i] = Password_Data[i];  //cardwdata ¶¨ÒåÃÜÔ¿ÔÝ´æÊý×é ³¤¶È6¸ö×Ö½Ú  £¬chData ´æ·ÅÐòÁÐºÅµÄ
             -£¬ÐòÁÐºÅÎª4¸ö×Ö½Ú
1110   1      
1111   1        card_new_key[0] = 0xFF;           //Õâ¸öÖµÄã¿É×Ô¼º¶¨Òå
1112   1        card_new_key[5] = 0xFF;     //Õâ¸öÖµÊÇ¿éºÅ £¬¼´Ã¿¸öÉÈÇøµÄ¿ØÖÆ¿éºÅÖµÊÇ²»Í¬µÄ   
1113   1      
1114   1        
1115   1        memcpy(newkey,card_new_key,16);
1116   1        
1117   1        memcpy(cardkey,card_new_key,6);
1118   1        
1119   1      
1120   1      
1121   1        return Do_True;
1122   1      }
1123          
1124          
1125          uchar RecoverPsw()     //ÃÜÔ¿´¦Àíº¯Êý Ò»¿¨Ò»ÃÜÔ¿£¬²»Í¬ÉÈÇø²»ÃÜÔ¿Ò²²»Í¬
1126          {
1127   1        uchar  i;
1128   1      
1129   1        for(i = 0; i < 4; i++)
1130   1          card_new_key[1 + i] = 0xFF;  //cardwdata ¶¨ÒåÃÜÔ¿ÔÝ´æÊý×é ³¤¶È6¸ö×Ö½Ú  £¬chData ´æ·ÅÐòÁÐºÅµÄ£¬ÐòÁÐºÅÎª4¸
             -ö×Ö½Ú
1131   1      
1132   1        card_new_key[0] = 0xFF;           //Õâ¸öÖµÄã¿É×Ô¼º¶¨Òå
1133   1        card_new_key[5] = 0xFF;     //Õâ¸öÖµÊÇ¿éºÅ £¬¼´Ã¿¸öÉÈÇøµÄ¿ØÖÆ¿éºÅÖµÊÇ²»Í¬µÄ   
1134   1        
1135   1        memcpy(newkey,card_new_key,16);
1136   1        
1137   1        memcpy(cardkey,card_new_key,6);
1138   1        
1139   1        return Do_True;
1140   1      }
1141          
1142          
1143          uchar ReadCardStatusData(uchar chOffset)
1144          { 
1145   1        uchar xdata temp[16];
1146   1        if(MI_RD_OK != readDataFromIc(cardkey,SECTION_0 + chOffset,temp))
1147   1          return Do_False;
1148   1      
1149   1        memcopy(maincmd, temp + 6, 5);
1150   1        if(MI_RD_OK != readDataFromIc(cardkey,SECTION_1 + chOffset,temp))
1151   1          return Do_False;
1152   1      
1153   1        memcopy(maincmd + 5, temp, 16);
1154   1        return Do_True;
1155   1      }
1156          
1157          uchar DoReplaceCardForbidenList(uchar iType, uchar chOffset)
1158          {
1159   1        uchar xdata temp[16] = {0};
1160   1        uchar  chRet = 0;
1161   1        uint  uiAddr = BLACK_LIST;
1162   1        
1163   1        if(iType == MANAGER_CARD)
1164   1          uiAddr = MGR_BLACK_LIST;
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 20  

1165   1        
1166   1        if(MI_RD_OK  !=  readDataFromIc(cardkey,SECTION_6 + chOffset,temp))
1167   1          return Do_False;
1168   1      
1169   1        if(temp[9] == 0x03)
1170   1        {
1171   2          Record2BlackList(iType, temp + 10);   
1172   2        }
1173   1        return Do_True;
1174   1      }
1175          
1176          
1177          uchar ReadProc(void)
1178          {
1179   1        uint  count=0;  
1180   1        uchar  chError = 0;
1181   1        uchar  chRet = 0;
1182   1        uchar  chReverseData = 0;
1183   1        uchar  chReverseData2 = 0;
1184   1        uchar xdata temp[16] = {0};
1185   1        uchar xdata temp1[16] = {0};  
1186   1        uchar xdata i=0;
1187   1        ulong xdata ulAgentID = 0;
1188   1        char chData = 0;
1189   1        
1190   1        
1191   1      //  if(g_ucAgentVerifyFlag == DO_VERIFY_AGENT)
1192   1      //  {
1193   1      //    if(GetVersion(g_chOffset) >= 0xA0)
1194   1      //    {
1195   1      //      if(CheckSerial(g_chOffset) != Do_True)
1196   1      //      {
1197   1      //        LongBeep();
1198   1      //        delay_10ms(1000);
1199   1      //        Sounds(1);
1200   1      //        return Do_False;
1201   1      //      }
1202   1      //    }
1203   1      //  }
1204   1      
1205   1        if(MI_RD_OK != readDataFromIc(cardkey,SECTION_0 + g_chOffset,temp))
1206   1        {
1207   2          RecoverPsw();
1208   2          
1209   2          chError = readDataFromIc(cardkey,SECTION_0 + g_chOffset,temp);
1210   2          
1211   2      //    memcpy(maincmd, cardkey, 6);
1212   2      //    
1213   2      //    maincmd[6] = chError;
1214   2      //    maincmd[7] = temp[4];
1215   2      //    maincmd[8] = temp[5];
1216   2      //    
1217   2      //    Make(0xFC,11,maincmd);
1218   2      //    Send(maincmd, 16);
1219   2          
1220   2          if(MI_RD_OK != chError 
1221   2            || temp[4] != 3 
1222   2            || (((temp[5] & 0x0F) != FUNC_TYPE_OFFSET) 
1223   2              && ((temp[5] & 0x0F) != FUNC_TYPE_Check))     
1224   2            )
1225   2          {
1226   3            GeneratePsw();
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 21  

1227   3            Sounds(2);
1228   3            delay_10ms(50000);
1229   3            LongBeep();
1230   3            //Sounds(1);
1231   3            return Do_False;
1232   3          }
1233   2          GeneratePsw();
1234   2        }
1235   1      
1236   1        //readtime(tmElevator);
1237   1        
1238   1        switch (temp[4]) //¿¨ÀàÐÍ
1239   1        {
1240   2        case 1://ÒµÖ÷¿¨ 
1241   2          //ÅÐ¶ÏÒµÖ÷ÔÚ²»ÔÚºÚÃûµ¥ÖÐ
1242   2          //if(INBLACKLIST == checkBlackList(CUSTOMER_CARD, temp+6))
1243   2          //{
1244   2          //  Sounds(4);
1245   2          //  return Do_False;
1246   2          //}
1247   2          
1248   2          if(GetDevice() == DISABLE)
1249   2          {   
1250   3            Sounds(2);
1251   3            return Do_False;
1252   3          }
1253   2          
1254   2          chRet = CheckBlackList(CUSTOMER_CARD, temp+6, &chReverseData2);
1255   2          if(INBLACKLIST == chRet)
1256   2          {     
1257   3            Sounds(2);
1258   3            delay_10ms(50000);
1259   3            Sounds(2);
1260   3            return Do_False;
1261   3          }
1262   2                
1263   2          if(g_ucReverseFlag == DO_REVERSE)
1264   2          {     
1265   3            chError = ReadCardReverseData(&chReverseData);
1266   3            chData = (chReverseData - chReverseData2) * (chReverseData2 - chReverseData) * -1;
1267   3            
1268   3            if(chReverseData != 0xFF 
1269   3              &&  chReverseData2 != 0xFF 
1270   3              && (chError != Do_True 
1271   3                || (chRet != NOINBLACKLIST
1272   3                //&& chReverseData != chReverseData2))
1273   3                  && chData > 2)))
1274   3            {
1275   4              maincmd[0] = 0 ;
1276   4              maincmd[1] = g_ucElevatorID ;
1277   4              maincmd[2] = temp[6];
1278   4              maincmd[3] = temp[7];
1279   4              maincmd[4] = temp[8];
1280   4              maincmd[5] = chError;
1281   4              maincmd[6] = chRet;
1282   4              maincmd[7] = chReverseData;
1283   4              maincmd[8] = chReverseData2;
1284   4              Make(0xF5,11,maincmd);
1285   4              Send(maincmd, 16);        
1286   4                
1287   4              Sounds(2);
1288   4              delay_10ms(50000);
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 22  

1289   4              Sounds(3);
1290   4              return Do_False;
1291   4            }
1292   3              
1293   3      //      chRet = CheckReverseData( CUSTOMER_CARD, temp + 6, chReverseData, &chReverseData2);
1294   3      //    
1295   3      //      if(Do_True != chError || REVERSE_CHECK_OK != chRet)
1296   3      //      {
1297   3      //        maincmd[0] = 0 ;
1298   3      //        maincmd[1] = g_ucElevatorID ;
1299   3      //        maincmd[2] = temp[6];
1300   3      //        maincmd[3] = temp[7];
1301   3      //        maincmd[4] = temp[8];
1302   3      //        maincmd[5] = chError;
1303   3      //        maincmd[6] = chRet;
1304   3      //        maincmd[7] = chReverseData;
1305   3      //        maincmd[8] = chReverseData2;
1306   3      //        Make(0xF5,11,maincmd);
1307   3      //        Send(maincmd, 16);        
1308   3      //          
1309   3      //        Sounds(2);
1310   3      //        delay_10ms(50000);
1311   3      //        Sounds(3);
1312   3      //        return Do_False;
1313   3      //      }
1314   3      
1315   3            chReverseData++;
1316   3            if(chReverseData == 0xFF)
1317   3              chReverseData = 0;
1318   3            
1319   3            if( Do_True == ReverseWriteData2Card(chReverseData))    
1320   3              RecordCardList(CUSTOMER_CARD, temp+6, chReverseData);
1321   3            if(Do_False == ReadCardReverseData(&chReverseData))
1322   3              RecordCardList(CUSTOMER_CARD, temp+6, 0xFF);      
1323   3          }
1324   2          
1325   2          ulAgentID = GetCardAgentID(g_chOffset);
1326   2      
1327   2          if(g_ucAgentVerifyFlag == DO_VERIFY_AGENT 
1328   2            && 0xFFFFFFFF != g_ulAgentID
1329   2            && ulAgentID != g_ulAgentID )
1330   2          {
1331   3            maincmd[0] = (ulAgentID >> 24) & 0xFF;
1332   3            maincmd[1] = (ulAgentID >> 16) & 0xFF;
1333   3            maincmd[2] = (ulAgentID >> 8) & 0xFF;
1334   3            maincmd[3] = ulAgentID & 0xFF;
1335   3            
1336   3            maincmd[4] = (g_ulAgentID >> 24) & 0xFF;
1337   3            maincmd[5] = (g_ulAgentID >> 16) & 0xFF;
1338   3            maincmd[6] = (g_ulAgentID >> 8) & 0xFF;
1339   3            maincmd[7] = g_ulAgentID & 0xFF;
1340   3      
1341   3            memcopy(maincmd + 8, cardkey, 16);
1342   3          
1343   3            Make(0xF5,26,maincmd);
1344   3            Send(maincmd, 31);
1345   3            
1346   3            Sounds(4);
1347   3            return Do_False;
1348   3          }
1349   2          if(temp[5] == 3)
1350   2            DoReplaceCardForbidenList(CUSTOMER_CARD, g_chOffset);
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 23  

1351   2      
1352   2          
1353   2          if(MI_RD_OK != readDataFromIc(cardkey, SECTION_1 + g_chOffset, temp))   
1354   2          {     
1355   3            Sounds(2);
1356   3            return Do_False;
1357   3          }
1358   2          
1359   2          for(i = 2; i < 12; i++ )
1360   2            temp[i] = temp[i] - i;
1361   2          
1362   2          if((temp[0]&0x03) == COUNTLIMIT)
1363   2          {
1364   3            //²éÑéÊ¹ÓÃ´ÎÊý
1365   3            if( CheckUseCount(&count, g_chOffset) != Do_True)
1366   3            {
1367   4              Sounds(1);
1368   4              delay_10ms(50000);
1369   4              Sounds(1);
1370   4              return Do_False;
1371   4            }
1372   3            
1373   3            DealElevator(temp[1]);
1374   3            
1375   3            maincmd[0] = count >> 8;
1376   3            maincmd[1] = count & 0xFF;
1377   3            maincmd[2] = temp[1];
1378   3            maincmd[3] = GetElevatorID();
1379   3            Make(5, 6,maincmd);
1380   3            Send(maincmd, 11);
1381   3          }
1382   2          else if((temp[0]&0x03) == DATELIMIT)
1383   2          {
1384   3            readtime(tmElevator);
1385   3      
1386   3            if(Do_True != checkTimeValide(temp+2,temp+7,tmElevator))
1387   3            {
1388   4              Sounds(1);
1389   4              delay_10ms(50000);
1390   4              Sounds(2);
1391   4              return Do_False;
1392   4            }
1393   3            DealElevator(temp[1]);
1394   3            
1395   3            for(i=0;i<7;i++)
1396   3              maincmd[i] = tmElevator[i];
1397   3            Make(5,9,maincmd);
1398   3            Send(maincmd, 14);
1399   3          }
1400   2          else if((temp[0]&0x03)==(COUNTLIMIT|DATELIMIT))
1401   2          {
1402   3            if( CheckUseCount( &count , g_chOffset) != Do_True)
1403   3            {
1404   4              Sounds(1);
1405   4              delay_10ms(50000);
1406   4              Sounds(1);
1407   4              return Do_False;
1408   4            }
1409   3            readtime(tmElevator);
1410   3            if(checkTimeValide(temp+2,temp+7,tmElevator) != Do_True)
1411   3            {
1412   4              Sounds(1);
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 24  

1413   4              delay_10ms(50000);
1414   4              Sounds(2);
1415   4              return Do_False;
1416   4            }
1417   3            
1418   3            DealElevator(temp[1]);
1419   3          }
1420   2          
1421   2      
1422   2          break;
1423   2        case 2://¹ÜÀíÔ±¿¨ 
1424   2          if(GetDevice() == DISABLE)
1425   2          {
1426   3            Sounds(2);
1427   3            return Do_False;
1428   3          }
1429   2          chRet = CheckBlackList(MANAGER_CARD, temp+6, &chReverseData2);
1430   2          if(INBLACKLIST == chRet)
1431   2          {         
1432   3            Sounds(2);
1433   3            delay_10ms(50000);
1434   3            Sounds(2);
1435   3            return Do_False;
1436   3            
1437   3          }
1438   2          
1439   2          //·­Ð´Ð£Ñé
1440   2          if(g_ucReverseFlag == DO_REVERSE)
1441   2          {
1442   3            chReverseData = 0;
1443   3            
1444   3            chError = ReadCardReverseData(&chReverseData);
1445   3            chData = (chReverseData - chReverseData2) * (chReverseData2 - chReverseData) * -1;
1446   3            
1447   3            if(chReverseData != 0xFF 
1448   3              &&  chReverseData2 != 0xFF 
1449   3              && (chError != Do_True 
1450   3                || (chRet != NOINBLACKLIST
1451   3                //&& chReverseData != chReverseData2))
1452   3                  && chData > 2)))            
1453   3            {         
1454   4              maincmd[0] = 0 ;
1455   4              maincmd[1] = g_ucElevatorID ;
1456   4              maincmd[2] = temp[6];
1457   4              maincmd[3] = temp[7];
1458   4              maincmd[4] = temp[8];
1459   4              maincmd[5] = chError;
1460   4              maincmd[6] = chRet;
1461   4              maincmd[7] = chReverseData;
1462   4              maincmd[8] = chReverseData2;
1463   4              Make(0xF5,11,maincmd);
1464   4              Send(maincmd, 16);        
1465   4                
1466   4              Sounds(2);
1467   4              delay_10ms(50000);
1468   4              Sounds(3);
1469   4              return Do_False;
1470   4            }
1471   3          
1472   3            //chRet = CheckReverseData( MANAGER_CARD, temp + 6, chReverseData, &chReverseData2);
1473   3          
1474   3            //if(Do_True != chError || REVERSE_CHECK_OK != chRet)     
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 25  

1475   3            //{         
1476   3            //  Sounds(2);
1477   3            //  delay_10ms(50000);
1478   3            //  Sounds(3);
1479   3            //  return Do_False;
1480   3            //}
1481   3      
1482   3            chReverseData++;
1483   3            
1484   3            if( Do_True == ReverseWriteData2Card(chReverseData))    
1485   3              RecordCardList(MANAGER_CARD, temp+6, chReverseData);  
1486   3            if(Do_False == ReadCardReverseData(&chReverseData))
1487   3              RecordCardList(MANAGER_CARD, temp+6, 0xFF);
1488   3            
1489   3          }
1490   2            
1491   2      
1492   2          ulAgentID = GetCardAgentID(g_chOffset);
1493   2      
1494   2          if(g_ucAgentVerifyFlag == DO_VERIFY_AGENT 
1495   2            && 0xFFFFFFFF != g_ulAgentID
1496   2            && ulAgentID != g_ulAgentID )
1497   2          {
1498   3            maincmd[0] = (ulAgentID >> 24) & 0xFF;
1499   3            maincmd[1] = (ulAgentID >> 16) & 0xFF;
1500   3            maincmd[2] = (ulAgentID >> 8) & 0xFF;
1501   3            maincmd[3] = ulAgentID & 0xFF;
1502   3            
1503   3            maincmd[4] = (g_ulAgentID >> 24) & 0xFF;
1504   3            maincmd[5] = (g_ulAgentID >> 16) & 0xFF;
1505   3            maincmd[6] = (g_ulAgentID >> 8) & 0xFF;
1506   3            maincmd[7] = g_ulAgentID & 0xFF;
1507   3      
1508   3            memcopy(maincmd + 8, cardkey, 16);
1509   3          
1510   3            Make(0xF5,26,maincmd);
1511   3            Send(maincmd, 31);
1512   3            
1513   3            Sounds(4);
1514   3            return Do_False;
1515   3          }
1516   2          //²¹¿¨¼ÇÂ¼Ç°Ò»¸ö¿¨ºÅ½øºÚÃûµ¥
1517   2          if(temp[5] == 3)
1518   2            DoReplaceCardForbidenList(MANAGER_CARD, g_chOffset);
1519   2          
1520   2          if(MI_RD_OK != readDataFromIc(cardkey,SECTION_1 + g_chOffset,temp))
1521   2            return Do_False;
1522   2          
1523   2          for(i = 2; i < 12; i++ )
1524   2            temp[i] = temp[i] - i;
1525   2          
1526   2          if((temp[0]&0x03) == COUNTLIMIT)
1527   2          {                 
1528   3            //²éÑéÊ¹ÓÃ´ÎÊý
1529   3            if( CheckUseCount( &count, g_chOffset ) != Do_True)
1530   3            {         
1531   4              Sounds(1);
1532   4              delay_10ms(50000);
1533   4              Sounds(1);
1534   4              return Do_False;
1535   4            }
1536   3          }
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 26  

1537   2          else if((temp[0]&0x03)==DATELIMIT)
1538   2          {
1539   3            readtime(tmElevator);
1540   3            //for(i=0;i<5;i++)
1541   3            //  maincmd[i]=time[i];
1542   3            //Make(5,7,maincmd);
1543   3            //Send(maincmd,9);
1544   3            if(Do_True != checkTimeValide(temp+2,temp+7,tmElevator))
1545   3            {
1546   4              Sounds(2);
1547   4              delay_10ms(50000);
1548   4              Sounds(2);
1549   4              return Do_False;
1550   4            }
1551   3          }
1552   2          else if((temp[0]&0x03) == (COUNTLIMIT|DATELIMIT))
1553   2          {
1554   3            if( CheckUseCount( &count, g_chOffset ) != Do_True)
1555   3            {
1556   4              Sounds(1);
1557   4              delay_10ms(50000);
1558   4              Sounds(1);
1559   4              return Do_False;
1560   4            }
1561   3            readtime(tmElevator);
1562   3            if(checkTimeValide(temp+2,temp+7,tmElevator) != Do_True)
1563   3            {
1564   4              Sounds(2);
1565   4              delay_10ms(50000);
1566   4              Sounds(2);
1567   4              return Do_False;
1568   4            }
1569   3          }
1570   2          DealElevator(temp[1]);
1571   2          
1572   2          break;
1573   2        case 3://¹¦ÄÜ¿¨
1574   2          if((temp[5] & 0x0F) == FUNC_TYPE_Check) 
1575   2          {
1576   3            RecoverPsw();
1577   3            
1578   3            if(Do_True == RecordInterParam(g_chOffset))
1579   3              Sounds(1);
1580   3            else        
1581   3              Sounds(2);
1582   3            
1583   3            GeneratePsw();
1584   3            
1585   3            return Do_True;
1586   3          }
1587   2          
1588   2          //ÏÈÐ£Ñé´úÀíID
1589   2          if(g_ucAgentVerifyFlag == DO_VERIFY_AGENT 
1590   2            && (temp[5] & 0x0F) != FUNC_TYPE_OFFSET)
1591   2          {
1592   3            if(GetCardAgentID(g_chOffset) != g_ulAgentID)
1593   3            {       
1594   4              g_ulAgentID = GetCardAgentID(g_chOffset);
1595   4              maincmd[0] = (g_ulAgentID >> 24) & 0xFF;
1596   4              maincmd[1] = (g_ulAgentID >> 16) & 0xFF;
1597   4              maincmd[2] = (g_ulAgentID >> 8) & 0xFF;
1598   4              maincmd[3] = (g_ulAgentID) & 0xFF;
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 27  

1599   4              
1600   4              g_ulAgentID = ReadAgentID();
1601   4              maincmd[4] = (g_ulAgentID >> 24) & 0xFF;
1602   4              maincmd[5] = (g_ulAgentID >> 16) & 0xFF;
1603   4              maincmd[6] = (g_ulAgentID >> 8) & 0xFF;
1604   4              maincmd[7] = (g_ulAgentID) & 0xFF;
1605   4              Make(0xff, 10, maincmd);
1606   4              Send(maincmd, 15);
1607   4              
1608   4              Sounds(2);
1609   4              return Do_False;
1610   4            }
1611   3          }
1612   2          
1613   2          if((temp[5] & 0x0F) == FUNC_TYPE_FORBIDEN)    //Æô½û¿¨
1614   2          {
1615   3            chError = DoFunctionEnableInfo(g_chOffset);
1616   3            maincmd[0] = chError;
1617   3            maincmd[1] = g_chOffset;
1618   3            maincmd[2] = 0;
1619   3            
1620   3            Make(0xfe, 5, maincmd);
1621   3            Send(maincmd, 10);        
1622   3            
1623   3            if(Do_True == chError)
1624   3              Sounds(1);
1625   3            else      
1626   3              Sounds(2);
1627   3            return Do_True;
1628   3          }
1629   2          else if((temp[5] & 0x0F) == FUNC_TYPE_CHECK_TIME) //Ð£Ê±¿¨
1630   2          {  
1631   3            if(MI_RD_OK == readDataFromIc(cardkey,SECTION_7 + g_chOffset,temp1))
1632   3            {
1633   4              maincmd[6]=temp1[0];
1634   4              maincmd[5]=temp1[1];
1635   4              maincmd[3]=temp1[2];
1636   4              maincmd[2]=temp1[3];
1637   4              maincmd[1]=temp1[4];
1638   4              maincmd[0]=temp1[5];
1639   4              maincmd[4]=temp1[6];
1640   4              
1641   4              P8563_settime(maincmd); 
1642   4              Sounds(1);
1643   4            }
1644   3            else
1645   3              Sounds(2);
1646   3            return Do_True;
1647   3          }
1648   2          else if((temp[5] & 0x0F) == FUNC_TYPE_SWITCH)  //¿ª¹Ø¿¨
1649   2          {     
1650   3            
1651   3            if(g_ucEnableFlag == 0)//Æô¶¯
1652   3            {
1653   4              SetDevice(ENABLE);
1654   4              enableKey(a);
1655   4              g_ucEnableFlag = 1;
1656   4            }
1657   3            else
1658   3            {
1659   4              SetDevice(DISABLE);
1660   4              enableKey(ENABLEALL);
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 28  

1661   4              g_ucEnableFlag = 0;
1662   4            }
1663   3            Sounds(1);
1664   3          }
1665   2          else if((temp[5] & 0x0F) == FUNC_TYPE_OFFSET)  // Æ«ÒÆ¿¨
1666   2          {
1667   3            //if(Do_True == WriteOffset( temp[6]))
1668   3            //if(Do_True == WriteOffsetPsw(temp + 6))
1669   3            //  Sounds(1);
1670   3            //else
1671   3            //  Sounds(2);
1672   3            //maincmd[0] = ReadOffset();
1673   3            //ReadSectionPsw(maincmd + 1);
1674   3      
1675   3            //if(g_chPasswordFlag == DO_PASSWORD)     
1676   3            if(g_chPasswordFlag == DO_PASSWORD)
1677   3              RecoverPsw();
1678   3            
1679   3            if(g_ucEnableSwitch == ENABLESWITCH)
1680   3            {       
1681   4              RecoverPsw();
1682   4            
1683   4              ulAgentID = GetCardAgentID(0 + g_chOffset);
1684   4              if(g_ulAgentID != GetCardAgentID(0 + g_chOffset))
1685   4              {
1686   5                    
1687   5                Sounds(3);
1688   5                delay_10ms(50000);
1689   5                Sounds(1);
1690   5                
1691   5                memset(maincmd, 0, 20);
1692   5                
1693   5                maincmd[0] = (ulAgentID >> 24) & 0xFF;
1694   5                maincmd[1] = (ulAgentID >> 16) & 0xFF;
1695   5                maincmd[2] = (ulAgentID >> 8) & 0xFF;
1696   5                maincmd[3] = ulAgentID & 0xFF;
1697   5                
1698   5                maincmd[4] = 0;
1699   5                
1700   5                maincmd[5] = (g_ulAgentID >> 24) & 0xFF;
1701   5                maincmd[6] = (g_ulAgentID >> 16) & 0xFF;
1702   5                maincmd[7] = (g_ulAgentID >> 8) & 0xFF;
1703   5                maincmd[8] = g_ulAgentID & 0xFF;
1704   5                
1705   5                Make(0xFB, 11, maincmd);
1706   5                Send(maincmd, 16);
1707   5      
1708   5                if(g_chPasswordFlag == DO_PASSWORD)
1709   5                  GeneratePsw();
1710   5                
1711   5                return Do_False;
1712   5              }
1713   4              
1714   4              if(g_ucEnableFlag == 0)//Æô¶¯
1715   4              {
1716   5                SetDevice(ENABLE);
1717   5                enableKey(a);
1718   5                g_ucEnableFlag = 1;
1719   5                
1720   5                Sounds(1);
1721   5              }
1722   4              else
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 29  

1723   4              {
1724   5                SetDevice(DISABLE);
1725   5                enableKey(ENABLEALL);
1726   5                g_ucEnableFlag = 0;
1727   5                
1728   5                Sounds(2);  
1729   5              }
1730   4              
1731   4              if(g_chPasswordFlag == DO_PASSWORD)
1732   4                GeneratePsw();
1733   4              
1734   4              memset(maincmd, 0, 20);
1735   4              maincmd[0] = g_ucEnableFlag;
1736   4              Make(0xFB, 7, maincmd);
1737   4              Send(maincmd, 12);
1738   4              
1739   4              return Do_True;
1740   4            }
1741   3      
1742   3            if(Do_True== ReadCardStatusData(g_chOffset))
1743   3            {         
1744   4              Sounds(3);
1745   4              
1746   4              WriteStatusData(maincmd);
1747   4              //write 2 times, ensuare OK
1748   4              WriteStatusData(maincmd);               
1749   4              
1750   4              g_chOffset = ReadOffset();  
1751   4              g_ulAgentID = ReadAgentID();    
1752   4              g_ucAgentVerifyFlag = ReadVerifyAgentFlag();
1753   4              g_chPasswordFlag = ReadPasswordFlag();
1754   4              g_ucReverseFlag = ReadReverseCheckFlag();
1755   4              ReadSectionPsw(Password_Data);  
1756   4              g_ucEnableSwitch = 0x01;
1757   4            }
1758   3            else
1759   3            {     
1760   4              Sounds(3);
1761   4              delay_10ms(50000);
1762   4              Sounds(2);
1763   4            }
1764   3            if(g_chPasswordFlag == DO_PASSWORD)
1765   3              GeneratePsw();
1766   3            
1767   3            memset(maincmd, 0, 16);     
1768   3            ReadStatusData(maincmd);      
1769   3            Make(0xFC, 16, maincmd);
1770   3            Send(maincmd, 21);
1771   3          }
1772   2          else if((temp[5] & 0x0F) == FUNC_TYPE_AGENT)  // ´úÀíÉÌ
1773   2          {
1774   3            //ÒÑ¾­ÊÚÈ¨¹ýµÄ£¬²»ÄÜÔÙÊÚÈ¨¸ÄÐ´ÁË
1775   3            if(g_ulAgentID != 0xFFFFFFFF)
1776   3            {
1777   4              if(g_ucEnableFlag == 0)//Æô¶¯
1778   4              {
1779   5                SetDevice(ENABLE);
1780   5                enableKey(a);
1781   5                g_ucEnableFlag = 1;
1782   5                Sounds(1);
1783   5              }
1784   4              else
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 30  

1785   4              {
1786   5                SetDevice(DISABLE);
1787   5                enableKey(ENABLEALL);
1788   5                g_ucEnableFlag = 0;
1789   5                Sounds(2);
1790   5              }
1791   4              return Do_True;
1792   4            }
1793   3            
1794   3            if(Do_True == WriteAgentID( temp + 6))
1795   3            {
1796   4              g_ulAgentID = ReadAgentID();
1797   4                
1798   4              maincmd[0] = g_ucAgentVerifyFlag;
1799   4              
1800   4              maincmd[1] = (g_ulAgentID >> 24) & 0xFF;
1801   4              maincmd[2] = (g_ulAgentID >> 16) & 0xFF;
1802   4              maincmd[3] = (g_ulAgentID >> 8) & 0xFF;
1803   4              maincmd[4] = (g_ulAgentID) & 0xFF;  
1804   4              maincmd[5] = 0;
1805   4              maincmd[6] = g_ucReverseFlag;
1806   4              Make(0xFF, 9, maincmd);
1807   4              Send(maincmd, 14);
1808   4              
1809   4              //Ð´´úÀíÐ£Ñé±ê¼Ç
1810   4              if(temp[10] == 0xAA)
1811   4              {
1812   5                WriteVerifyAgentFlag(0x01);
1813   5                g_ucAgentVerifyFlag = ReadVerifyAgentFlag();
1814   5                Sounds(1);
1815   5              }   
1816   4              
1817   4              Sounds(3);
1818   4            }
1819   3            else
1820   3            {
1821   4              Sounds(4);
1822   4              delay_10ms(200);
1823   4              Sounds(1);
1824   4            }
1825   3          }
1826   2          
1827   2          else if((temp[5] & 0x0F) == FUNC_TYPE_CLEARBLACKLIST)  //Çå¿ÕºÚÃûµ¥
1828   2          {
1829   3            //ClearBlackList();
1830   3            ClearAllReverseList();
1831   3            Sounds(2);
1832   3            delay_10ms(200);
1833   3            Sounds(2);
1834   3          }
1835   2          else if((temp[5] & 0x0F) == FUNC_TYPE_ENABLECOUNTER)  //¿ªÆô¼ÆÊý
1836   2          {
1837   3            g_ucDisCounter = EnableCounter();
1838   3            Sounds(1);
1839   3          }
1840   2          else if((temp[5] & 0x0F) == FUNC_TYPE_DISABLECOUNTER)  //¹Ø±Õ¼ÆÊý
1841   2          {
1842   3            g_ucDisCounter = DisableCounter();
1843   3            Sounds(2);
1844   3          }
1845   2          else
1846   2          {
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 31  

1847   3            LongBeep();
1848   3          }
1849   2          
1850   2          break;
1851   2        default:
1852   2          {
1853   3            RecoverPsw();
1854   3              
1855   3            chError = readDataFromIc(cardkey,SECTION_0,temp);
1856   3            if(chError == Do_True 
1857   3              && temp[4] == 3 
1858   3              && (temp[5] & 0x0F) == FUNC_TYPE_OFFSET)  // Æ«ÒÆ¿¨
1859   3            {
1860   4              if(g_ucEnableSwitch == ENABLESWITCH)
1861   4              {     
1862   5                if(g_ulAgentID != GetCardAgentID(0))
1863   5                {
1864   6                  Sounds(3);
1865   6                  return Do_False;
1866   6                }
1867   5                
1868   5                if(g_ucEnableFlag == 0)//Æô¶¯
1869   5                {
1870   6                  SetDevice(ENABLE);
1871   6                  enableKey(a);
1872   6                  g_ucEnableFlag = 1;
1873   6                  Sounds(1);
1874   6                }
1875   5                else
1876   5                {
1877   6                  SetDevice(DISABLE);
1878   6                  enableKey(ENABLEALL);
1879   6                  g_ucEnableFlag = 0;
1880   6                  Sounds(2);
1881   6                }
1882   5                memset(maincmd, 3, 20);
1883   5                maincmd[0] = g_ucEnableFlag;
1884   5                Make(0xFB, 7, maincmd);
1885   5                Send(maincmd, 12);
1886   5                
1887   5                return Do_True;
1888   5              }
1889   4      
1890   4            }
1891   3            else
1892   3              Sounds(3);
1893   3            
1894   3            if(g_chPasswordFlag == DO_PASSWORD)
1895   3              GeneratePsw();
1896   3          }
1897   2          break;      
1898   2        }
1899   1        
1900   1        return Do_True;
1901   1      }
1902          
1903          
1904          void Uart1(void) interrupt 4 using 2
1905          {  
1906   1        if(RI)
1907   1        {
1908   2          SCON  = SCON & 0xfe;
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 32  

1909   2      
1910   2          bt_buf[bufini++] = SBUF;
1911   2          if (bufini >= BUFINLEN) 
1912   2            bufini = 0;
1913   2        }
1914   1        else if(TI)
1915   1        {
1916   2          SCON = SCON & 0xFd;
1917   2      
1918   2          if(internal2)
1919   2          {
1920   3            if(!(--counter2))
1921   3              internal2 = 0; 
1922   3            else 
1923   3              SBUF = *pp2++;//SBUF = XBYTE[pn++];
1924   3          }
1925   2        }
1926   1      }
1927          void Uart2(void) interrupt 8 using 2
1928          {  
1929   1        if(RI2)
1930   1        {
1931   2          S2CON  = S2CON & 0xfe;
1932   2      
1933   2          bt_buf[bufini++] = S2BUF;
1934   2          if (bufini >= BUFINLEN) bufini = 0;
1935   2        }
1936   1        else if(TI2)
1937   1        {
1938   2          S2CON  = S2CON & 0xFd;
1939   2      
1940   2          if(internal2)
1941   2          {
1942   3            if(!(--counter2))
1943   3              internal2 = 0; 
1944   3            else 
1945   3              S2BUF = *pp2++;//SBUF = XBYTE[pn++];
1946   3          }
1947   2        }
1948   1      } 
1949          
1950          
1951          
1952          
1953          //ÏµÍ³Ö÷º¯Êý
1954          void main (void)
1955          {
1956   1        uchar xdata  i;
1957   1        bit  init_go = 0;
1958   1        unsigned long xdata main_delay = 0; 
1959   1        unsigned int xdata test;
1960   1        uchar xdata uDisableOutput = 0;
1961   1        P3M0 |= 0XC0;P3M1 &= 0x3F;
1962   1        P4M0 |= 0x1E;P4M1 &= 0xE1;
1963   1        P2M0 |= 0x03;P2M1 &= 0x0C;
1964   1      
1965   1        //P0M0 = 0xF4;
1966   1        //P0M1 = 0x08;
1967   1        //P0M0 = 0xE4;
1968   1        //P0M1 = 0x10;    BLACK_LIST
1969   1      
1970   1        Time_init();    //Á½¸ö¶¨Ê±Æ÷³õÊ¼»¯
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 33  

1971   1        UART_init () ;
1972   1        EA = 1;
1973   1        
1974   1        PcdReset();
1975   1        PcdAntennaOff(); 
1976   1        PcdAntennaOn();  
1977   1        M500PcdConfigISOType( 'A' );
1978   1        //halRfReceivePacket(RxBuf, &leng);
1979   1        LEDON 
1980   1        if(IapReadByte(ENABLEORNOTSHANQU) == 0xff)
1981   1        {
1982   2          IapProgramByte(ENABLEORNOTSHANQU, ENABLE);
1983   2        } 
1984   1        Sounds(1);
1985   1        
1986   1        FMQOFF
1987   1        
1988   1        dis_open();
1989   1        //Send_data_A(0xaa,0xaa);
1990   1        //Send_data_B(0X55,0X55);
1991   1        if(GetDevice() == ENABLE)
1992   1        {
1993   2          enableKey(a);
1994   2          pressKey(b);
1995   2        }
1996   1        else 
1997   1        {
1998   2          enableKey(ENABLEALL);
1999   2        }
2000   1        
2001   1        for(i = 0;i<30;i++)
2002   1        {
2003   2          Delay1();
2004   2          Delay1();
2005   2          Delay1();
2006   2          Delay1();
2007   2        } 
2008   1      
2009   1        if(TRUE == IsReset())
2010   1        {
2011   2          LongBeep();
2012   2          Sounds(2);
2013   2          flash(3);
2014   2          
2015   2          g_ulAgentID = ReadAgentID();
2016   2          for(i =0; i < 16; i++)
2017   2            maincmd[i] = 0xFF;
2018   2      
2019   2          IapReadBytes(AGENT_DATA_ADDR,Agent_Data,4);
2020   2          
2021   2          maincmd[AGENT_DATA_ADDR] = Agent_Data[0];
2022   2          maincmd[AGENT_DATA_ADDR + 1] = Agent_Data[1];
2023   2          maincmd[AGENT_DATA_ADDR + 2] = Agent_Data[2];
2024   2          maincmd[AGENT_DATA_ADDR + 3] = Agent_Data[3];
2025   2      
2026   2          
2027   2          maincmd[INNER_FLAG_ADDR] = 0;
2028   2          
2029   2          IapEraseSector(DEVICE_STATUS_ADDR);
2030   2          
2031   2          IapProgramBytes(DEVICE_STATUS_ADDR,maincmd,16);
2032   2      
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 34  

2033   2          ClearAllReverseList();    
2034   2          
2035   2          IapProgramBytes(DEVICE_STATUS_ADDR,maincmd,16);
2036   2            
2037   2          Make(0xFA, 18, maincmd);
2038   2          Send(maincmd, 23);
2039   2      
2040   2          g_ulAgentID = ReadAgentID();
2041   2          memset(maincmd, 0, 6);
2042   2          maincmd[2] = (g_ulAgentID >> 24) & 0xFF;
2043   2          maincmd[3] = (g_ulAgentID >> 16) & 0xFF;
2044   2          maincmd[4] = (g_ulAgentID >> 8) & 0xFF;
2045   2          maincmd[5] = (g_ulAgentID) & 0xFF;
2046   2      
2047   2          Make(0xFA, 6, maincmd);
2048   2          Send(maincmd, 11);
2049   2        }
2050   1      
2051   1        maincmd[0] = ReadInnerFlag();
2052   1        if(maincmd[0] != 0xFF && (maincmd[0] & ENABLESWITCH) == ENABLESWITCH)
2053   1          g_ucEnableSwitch = ENABLESWITCH;
2054   1        
2055   1        g_chOffset = ReadOffset();  
2056   1        g_ulAgentID = ReadAgentID();    
2057   1        g_ucAgentVerifyFlag = ReadVerifyAgentFlag();
2058   1        g_chPasswordFlag = ReadPasswordFlag();
2059   1        g_ucReverseFlag = ReadReverseCheckFlag();
2060   1        ReadSectionPsw(Password_Data);  
2061   1        g_ucDisCounter = ReadDisableCounterFlag();
2062   1        
2063   1        maincmd[0] = g_chOffset;
2064   1        maincmd[1] = g_ucAgentVerifyFlag;
2065   1        maincmd[2] = (g_ulAgentID >> 24) & 0xFF;
2066   1        maincmd[3] = (g_ulAgentID >> 16) & 0xFF;
2067   1        maincmd[4] = (g_ulAgentID >> 8) & 0xFF;
2068   1        maincmd[5] = (g_ulAgentID) & 0xFF;
2069   1        
2070   1        maincmd[6] = g_chPasswordFlag;
2071   1        memcpy(maincmd + 7, Password_Data, 4);  
2072   1        maincmd[11] = g_ucReverseFlag;
2073   1        maincmd[12] = g_ucDisCounter;
2074   1        
2075   1        Make(0xFF, 15, maincmd);
2076   1        Send(maincmd, 20);
2077   1      
2078   1        if(g_chPasswordFlag == DO_PASSWORD)
2079   1        {
2080   2          GeneratePsw();
2081   2          
2082   2          //memcpy(newkey,card_new_key,16);   
2083   2          //memcpy(cardkey,card_new_key,6);
2084   2          
2085   2          memcpy(maincmd,newkey,16);
2086   2          Make(0xF9,18,maincmd);
2087   2          Send(maincmd,23); 
2088   2        }
2089   1      
2090   1        g_ucElevatorID = GetElevatorID();
2091   1      
2092   1        readtime(tmElevator);
2093   1        if(tmElevator[0] < 0x17)
2094   1        {
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 35  

2095   2          tmElevator[0] = 0x17;
2096   2          tmElevator[1] = 0x1;
2097   2          tmElevator[2] = 0x1;
2098   2          tmElevator[3] = 0x0;
2099   2          tmElevator[4] = 0x0;
2100   2          tmElevator[5] = 0x0;
2101   2          tmElevator[6] = 0x0;
2102   2          
2103   2          P8563_settime(tmElevator);
2104   2        }
2105   1        
2106   1        while(1)
2107   1        {
2108   2          for(i = 0;i<30;i++)
2109   2          {
2110   3            Delay1();
2111   3            Delay1();
2112   3            Delay1();
2113   3            Delay1();
2114   3          }
2115   2          
2116   2          ScanCommand();
2117   2      
2118   2          cardtypstu = PcdRequest( PICC_REQIDL,cardtyp);        //Ñ°¿¨
2119   2          
2120   2          if(cardtypstu == MI_OK)
2121   2          { 
2122   3            LEDCARD_ON
2123   3              
2124   3            ReadProc();
2125   3            init_go = 1;
2126   3            test = 0;
2127   3            PcdHalt();
2128   3            
2129   3            LEDCARD_OFF
2130   3          }
2131   2      
2132   2          
2133   2          if(TRUE == IsDisableOutput())
2134   2          {   
2135   3            if(uDisableOutput == 0)
2136   3              Sounds(1);
2137   3            uDisableOutput = 1;
2138   3            enableKey(ENABLEALL);
2139   3          }
2140   2          else
2141   2          {
2142   3            init_go = 1;
2143   3          }
2144   2          
2145   2          if(init_go)
2146   2            test++;
2147   2          
2148   2          if(test > 15)
2149   2          {
2150   3            init_go = 0;
2151   3            test = 0;
2152   3            if(GetDevice() == ENABLE && FALSE == IsDisableOutput()) 
2153   3            {
2154   4              enableKey(a);
2155   4              pressKey(b);
2156   4      
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 36  

2157   4              if(uDisableOutput == 1)
2158   4                Sounds(1);
2159   4              uDisableOutput = 0;
2160   4            }
2161   3          }
2162   2          main_delay++;
2163   2          if(main_delay > 600000)
2164   2          {
2165   3            main_delay = 0;
2166   3            PcdReset();
2167   3            PcdAntennaOff(); 
2168   3            PcdAntennaOn();  
2169   3            M500PcdConfigISOType( 'A' );
2170   3          }
2171   2          /*
2172   2          else 
2173   2            senduart(&zhuangtai,1);
2174   2          
2175   2          cardnumstu = PcdAnticoll(cardnum);          //»ñÈ¡¿¨µÄ¿¨ºÅ·À³åÍ»
2176   2      
2177   2          if(cardnumstu == MI_OK)
2178   2            Send(cardnum,4);
2179   2          cardsizestu = PcdSelect(cardnum,cardsize);    //Ñ¡¿¨²¢·µ»Ø¿¨ÈÝÁ¿
2180   2      
2181   2          if(cardsizestu == MI_OK)
2182   2            Send(cardsize,1);
2183   2          cardcheckstu = PcdAuthState(PICC_AUTHENT1A,0x1,cardkey,cardnum);  //¿é£¬ÑéÖ¤ÃÜÂë
2184   2      
2185   2          if(cardcheckstu == MI_OK)
2186   2          {
2187   2            LEDON;
2188   2          }
2189   2          cardknumstu = PcdRead(0x1,cardknum);        //¶ÁÈ¡ÑéÖ¤ÉÈÇø¿éµÄÄÚÈÝ
2190   2      
2191   2          if(cardknumstu == MI_OK)
2192   2          {
2193   2            Send(cardknum,16);
2194   2          } 
2195   2          if(test == 255)
2196   2            cardwdatastu = PcdWrite(0x1,cardwdata);     //ÑéÖ¤ºóÖØÐ´¿éÄÚÈÝ
2197   2          if(cardwdatastu == MI_OK){LEDOFF;}
2198   2      
2199   2          cardknumstu = 0;
2200   2      
2201   2          cardcheckstu = 0;
2202   2          cardtypstu = 0;
2203   2          cardnumstu = 0;
2204   2          cardsizestu = 0;
2205   2          if(test == 255)
2206   2            writeDataToIc(cardkey,0,cardwdata);
2207   2          */
2208   2        }
2209   1      }
2210          
2211          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  10839    ----
   CONSTANT SIZE    =     87    ----
   XDATA SIZE       =    266     250
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.53.0.0   MAIN                                                              08/21/2017 21:04:33 PAGE 37  

   DATA SIZE        =      5     220
   IDATA SIZE       =      2       3
   BIT SIZE         =      2       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
