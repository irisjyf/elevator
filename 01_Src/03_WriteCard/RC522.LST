C51 COMPILER V9.53.0.0   RC522                                                             07/16/2017 23:21:50 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE RC522
OBJECT MODULE PLACED IN ..\04_bin\WriteCard\RC522.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE RC522.C OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND OBJECT(..\04_bin\Wri
                    -teCard\RC522.obj)

line level    source

   1          #include <intrins.h>
   2          #include "STC15Fxxxx.h"
   3          
   4          //#include "main.h"
   5          #include "mfrc522.h"
   6          #include"string.h"
   7          //#include <string.h> 
   8          #define MAXRLEN 18  
   9          
  10          sbit MF522_NSS=P4^5;
  11          sbit MF522_SI=P2^6;
  12          sbit MF522_SO=P2^5;
  13          sbit MF522_SCK=P2^7;
  14          sbit MF522_RST=P2^4;  
  15          unsigned char code blockIdToIndex[50]={
  16                                               1, 2,              //第0 扇区
  17                                            4, 5, 6,              //第1 扇区
  18                                                                            8, 9, 10,             //第2 扇区
  19                                                                            12,13,14,             //第3 扇区
  20                                                                            16,17,18,             //第4 扇区
  21                                                                            20,21,22,             //第5 扇区
  22                                                                            24,25,26,             //第6 扇区
  23                                                                            28,29,30,             //第7 扇区
  24                                                                            32,33,34,             //第8 扇区
  25                                                                            36,37,38,             //第9 扇区
  26                                                                            40,41,42,             //第10扇区
  27                                                                            44,45,46,             //第11扇区
  28                                                                            48,49,50,             //第12扇区
  29                                                                            52,53,54,             //第13扇区
  30                                                                            56,57,58,             //第14扇区
  31                                                                            60,61,62              //第15扇区
  32                                                                            };
  33          
  34          //unsigned char code PswSectionIndex[]={3,7,11,15,19,23,27,31,35,39,43,47,51,55,59,63);
  35          unsigned char code PswSectionIndex[]={0,1,2,3,4,5,6,7,8,9,0xA,11,12,13,14,15};
  36          
  37          unsigned char CalcAreaofSection(unsigned char nSection)
  38          {
  39   1              return blockIdToIndex[nSection] / 4;
  40   1      }
  41          
  42          
  43          //unsigned char GetSectionIndex(unsigned char nSection)
  44          //{
  45          //      return blockIdToIndex[nSection];
  46          //}
  47          
  48          
  49          void delay_10ms(unsigned char n)
  50          {
  51   1          unsigned char timere=0;
  52   1              timere=10*n;
  53   1              while(10*n--);
  54   1      } 
C51 COMPILER V9.53.0.0   RC522                                                             07/16/2017 23:21:50 PAGE 2   

  55          //void Delay1() //延时程序
  56          //{
  57          //    uint i;
  58          //    uint d=1000;
  59          //    while (d--)
  60          //    {
  61          //        i=10;
  62          //        while (i--);
  63          //    }
  64          //}                   
  65          /////////////////////////////////////////////////////////////////////
  66          //功    能：寻卡
  67          //参数说明: req_code[IN]:寻卡方式
  68          //                0x52 = 寻感应区内所有符合14443A标准的卡
  69          //                0x26 = 寻未进入休眠状态的卡
  70          //          pTagType[OUT]：卡片类型代码
  71          //                0x4400 = Mifare_UltraLight
  72          //                0x0400 = Mifare_One(S50)
  73          //                0x0200 = Mifare_One(S70)
  74          //                0x0800 = Mifare_Pro(X)
  75          //                0x4403 = Mifare_DESFire
  76          //返    回: 成功返回MI_OK
  77          /////////////////////////////////////////////////////////////////////
  78          char PcdRequest(unsigned char req_code,unsigned char *pTagType)
  79          {
  80   1         char status;  
  81   1         unsigned int  unLen;
  82   1         unsigned char ucComMF522Buf[MAXRLEN]; 
  83   1      //  unsigned char xTest ;
  84   1         ClearBitMask(Status2Reg,0x08);
  85   1         WriteRawRC(BitFramingReg,0x07);
  86   1      
  87   1      //  xTest = ReadRawRC(BitFramingReg);
  88   1      //  if(xTest == 0x07 )
  89   1       //   { LED_GREEN  =0 ;}
  90   1       // else {LED_GREEN =1 ;while(1){}}
  91   1         SetBitMask(TxControlReg,0x03);
  92   1       
  93   1         ucComMF522Buf[0] = req_code;
  94   1      
  95   1         status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
  96   1      //     if(status  == MI_OK )
  97   1      //   { LED_GREEN  =0 ;}
  98   1      //   else {LED_GREEN =1 ;}
  99   1         if ((status == MI_OK) && (unLen == 0x10))
 100   1         {    
 101   2             *pTagType     = ucComMF522Buf[0];
 102   2             *(pTagType+1) = ucComMF522Buf[1];
 103   2         }
 104   1         else
 105   1         {   status = MI_ERR;   }
 106   1         
 107   1         return status;
 108   1      }
 109          
 110          /////////////////////////////////////////////////////////////////////
 111          //功    能：防冲撞
 112          //参数说明: pSnr[OUT]:卡片序列号，4字节
 113          //返    回: 成功返回MI_OK
 114          /////////////////////////////////////////////////////////////////////  
 115          char PcdAnticoll(unsigned char *pSnr)
 116          {
C51 COMPILER V9.53.0.0   RC522                                                             07/16/2017 23:21:50 PAGE 3   

 117   1          char status;
 118   1          unsigned char i,snr_check=0;
 119   1          unsigned int  unLen;                                                                                          
 120   1          unsigned char ucComMF522Buf[MAXRLEN]; 
 121   1          
 122   1      
 123   1          ClearBitMask(Status2Reg,0x08);
 124   1          WriteRawRC(BitFramingReg,0x00);
 125   1          ClearBitMask(CollReg,0x80);
 126   1       
 127   1          ucComMF522Buf[0] = PICC_ANTICOLL1;                                                                            
 128   1          ucComMF522Buf[1] = 0x20;
 129   1      
 130   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
 131   1      
 132   1          if (status == MI_OK)
 133   1          {
 134   2               for (i=0; i<4; i++)
 135   2               {   
 136   3                   *(pSnr+i)  = ucComMF522Buf[i];
 137   3                   snr_check ^= ucComMF522Buf[i];
 138   3               }
 139   2               if (snr_check != ucComMF522Buf[i])
 140   2               {   status = MI_ERR;    }
 141   2          }                                                                                                    
 142   1          
 143   1          SetBitMask(CollReg,0x80);
 144   1          return status;
 145   1      }
 146          
 147          /////////////////////////////////////////////////////////////////////
 148          //功    能：选定卡片
 149          //参数说明: pSnr[IN]:卡片序列号，4字节
 150          //返    回: 成功返回MI_OK
 151          /////////////////////////////////////////////////////////////////////
 152          char PcdSelect(unsigned char *pSnr,unsigned char *size)
 153          {
 154   1          char status;
 155   1          unsigned char i;
 156   1          unsigned int  unLen;
 157   1          unsigned char ucComMF522Buf[MAXRLEN]; 
 158   1          
 159   1          ucComMF522Buf[0] = PICC_ANTICOLL1;
 160   1          ucComMF522Buf[1] = 0x70;
 161   1          ucComMF522Buf[6] = 0;
 162   1          for (i=0; i<4; i++)
 163   1          {
 164   2              ucComMF522Buf[i+2] = *(pSnr+i);
 165   2              ucComMF522Buf[6]  ^= *(pSnr+i);
 166   2          }
 167   1          CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
 168   1        
 169   1          ClearBitMask(Status2Reg,0x08);
 170   1      
 171   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
 172   1          
 173   1          if ((status == MI_OK) && (unLen == 0x18))
 174   1          {   status = MI_OK;*size=ucComMF522Buf[0];  }
 175   1          else
 176   1          {   status = MI_ERR;    }
 177   1      
 178   1          return status;
C51 COMPILER V9.53.0.0   RC522                                                             07/16/2017 23:21:50 PAGE 4   

 179   1      }
 180          
 181          /////////////////////////////////////////////////////////////////////
 182          //功    能：验证卡片密码
 183          //参数说明: auth_mode[IN]: 密码验证模式
 184          //                 0x60 = 验证A密钥
 185          //                 0x61 = 验证B密钥 
 186          //          addr[IN]：块地址
 187          //          pKey[IN]：密码
 188          //          pSnr[IN]：卡片序列号，4字节
 189          //返    回: 成功返回MI_OK
 190          /////////////////////////////////////////////////////////////////////               
 191          char PcdAuthState(unsigned char auth_mode,unsigned char addr,unsigned char *pKey,unsigned char *pSnr)
 192          {
 193   1          char status;
 194   1          unsigned int  unLen;
 195   1          unsigned char i,ucComMF522Buf[MAXRLEN]; 
 196   1                                                                                                                                
 197   1          ucComMF522Buf[0] = auth_mode;
 198   1          ucComMF522Buf[1] = addr;
 199   1          for (i=0; i<6; i++)
 200   1          {    
 201   2              ucComMF522Buf[i+2] = *(pKey+i);   
 202   2              }
 203   1          for (i=0; i<4; i++)
 204   1          {    
 205   2              ucComMF522Buf[i+8] = *(pSnr+i);   
 206   2              }
 207   1          memcpy(&ucComMF522Buf[2], pKey, 6); 
 208   1          memcpy(&ucComMF522Buf[8], pSnr, 4); 
 209   1          
 210   1          status = PcdComMF522(PCD_AUTHENT,ucComMF522Buf,12,ucComMF522Buf,&unLen);
 211   1          if ((status != MI_OK) || (!(ReadRawRC(Status2Reg) & 0x08)))
 212   1          {   
 213   2              status = MI_ERR;   
 214   2              }                                                                        
 215   1          
 216   1          return status;
 217   1      }
 218          
 219          /////////////////////////////////////////////////////////////////////
 220          //功    能：读取M1卡一块数据
 221          //参数说明: addr[IN]：块地址
 222          //          pData[OUT]：读出的数据，16字节
 223          //返    回: 成功返回MI_OK
 224          ///////////////////////////////////////////////////////////////////// 
 225          char PcdRead(unsigned char addr,unsigned char *pData)
 226          {
 227   1          char status;
 228   1          unsigned int  unLen;
 229   1          unsigned char i,ucComMF522Buf[MAXRLEN]; 
 230   1      
 231   1          ucComMF522Buf[0] = PICC_READ;
 232   1          ucComMF522Buf[1] = addr;
 233   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 234   1         
 235   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 236   1          if ((status == MI_OK) && (unLen == 0x90))
 237   1       //   {   memcpy(pData, ucComMF522Buf, 16);   }
 238   1          {
 239   2              for (i=0; i<16; i++)
 240   2              {    *(pData+i) = ucComMF522Buf[i];   }
C51 COMPILER V9.53.0.0   RC522                                                             07/16/2017 23:21:50 PAGE 5   

 241   2          }
 242   1          else
 243   1          {   status = MI_ERR;   }
 244   1          
 245   1          return status;
 246   1      }
 247          
 248          /////////////////////////////////////////////////////////////////////
 249          //功    能：写数据到M1卡一块
 250          //参数说明: addr[IN]：块地址
 251          //          pData[IN]：写入的数据，16字节
 252          //返    回: 成功返回MI_OK
 253          /////////////////////////////////////////////////////////////////////                  
 254          char PcdWrite(unsigned char addr,unsigned char *pData)
 255          {
 256   1          char status;
 257   1          unsigned int  unLen;
 258   1          unsigned char i,ucComMF522Buf[MAXRLEN]; 
 259   1          
 260   1          ucComMF522Buf[0] = PICC_WRITE;
 261   1          ucComMF522Buf[1] = addr;
 262   1          CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 263   1       
 264   1          status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 265   1      
 266   1          if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
 267   1          {   status = MI_ERR;   }
 268   1              
 269   1          if (status == MI_OK)
 270   1          {
 271   2              //memcpy(ucComMF522Buf, pData, 16);
 272   2              for (i=0; i<16; i++)
 273   2              {    ucComMF522Buf[i] = *(pData+i);   }
 274   2              CalulateCRC(ucComMF522Buf,16,&ucComMF522Buf[16]);
 275   2      
 276   2              status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,18,ucComMF522Buf,&unLen);
 277   2              if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
 278   2              {   status = MI_ERR;   }
 279   2          }
 280   1          
 281   1          return status;
 282   1      }
 283          
 284           
 285            
 286          /////////////////////////////////////////////////////////////////////
 287          //功    能：命令卡片进入休眠状态
 288          //返    回: 成功返回MI_OK
 289          /////////////////////////////////////////////////////////////////////
 290          /*char PcdHalt(void)
 291          {
 292              char status;
 293              unsigned int  unLen;
 294              unsigned char ucComMF522Buf[MAXRLEN]; 
 295          
 296              ucComMF522Buf[0] = PICC_HALT;
 297              ucComMF522Buf[1] = 0;
 298              CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 299           
 300              status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 301          
 302              return MI_OK;
C51 COMPILER V9.53.0.0   RC522                                                             07/16/2017 23:21:50 PAGE 6   

 303          }                          */
 304          
 305          /////////////////////////////////////////////////////////////////////
 306          //用MF522计算CRC16函数
 307          /////////////////////////////////////////////////////////////////////
 308          void CalulateCRC(unsigned char *pIndata,unsigned char len,unsigned char *pOutData)
 309          {
 310   1          unsigned char i,n;
 311   1          ClearBitMask(DivIrqReg,0x04);
 312   1          WriteRawRC(CommandReg,PCD_IDLE);
 313   1          SetBitMask(FIFOLevelReg,0x80);
 314   1          for (i=0; i<len; i++)
 315   1          {   WriteRawRC(FIFODataReg, *(pIndata+i));   }
 316   1          WriteRawRC(CommandReg, PCD_CALCCRC);
 317   1          i = 0xFF;
 318   1          do 
 319   1          {
 320   2              n = ReadRawRC(DivIrqReg);
 321   2              i--;
 322   2          }
 323   1          while ((i!=0) && !(n&0x04));
 324   1          pOutData[0] = ReadRawRC(CRCResultRegL);
 325   1          pOutData[1] = ReadRawRC(CRCResultRegM);
 326   1      }
 327          
 328          /////////////////////////////////////////////////////////////////////
 329          //功    能：复位RC522
 330          //返    回: 成功返回MI_OK
 331          /////////////////////////////////////////////////////////////////////
 332          char PcdReset(void)
 333          {
 334   1          MF522_RST=1;
 335   1          _nop_();
 336   1          MF522_RST=0;
 337   1          _nop_();
 338   1          MF522_RST=1;
 339   1           _nop_();
 340   1          WriteRawRC(CommandReg,PCD_RESETPHASE);
 341   1          _nop_();
 342   1          
 343   1          WriteRawRC(ModeReg,0x3D);            //和Mifare卡通讯，CRC初始值0x6363
 344   1          WriteRawRC(TReloadRegL,30);           
 345   1          WriteRawRC(TReloadRegH,0);
 346   1          WriteRawRC(TModeReg,0x8D);
 347   1          WriteRawRC(TPrescalerReg,0x3E);
 348   1          WriteRawRC(TxAutoReg,0x40);     
 349   1          return MI_OK;
 350   1      }
 351          //////////////////////////////////////////////////////////////////////
 352          //设置RC632的工作方式 
 353          //////////////////////////////////////////////////////////////////////
 354          char M500PcdConfigISOType(unsigned char type)
 355          {
 356   1         if (type == 'A')                     //ISO14443_A
 357   1         { 
 358   2             ClearBitMask(Status2Reg,0x08);
 359   2      
 360   2       /*     WriteRawRC(CommandReg,0x20);    //as default   
 361   2             WriteRawRC(ComIEnReg,0x80);     //as default
 362   2             WriteRawRC(DivlEnReg,0x0);      //as default
 363   2                 WriteRawRC(ComIrqReg,0x04);     //as default
 364   2                 WriteRawRC(DivIrqReg,0x0);      //as default
C51 COMPILER V9.53.0.0   RC522                                                             07/16/2017 23:21:50 PAGE 7   

 365   2                 WriteRawRC(Status2Reg,0x0);//80    //trun off temperature sensor
 366   2                 WriteRawRC(WaterLevelReg,0x08); //as default
 367   2             WriteRawRC(ControlReg,0x20);    //as default
 368   2                 WriteRawRC(CollReg,0x80);    //as default
 369   2      */
 370   2             WriteRawRC(ModeReg,0x3D);//3F
 371   2      /*         WriteRawRC(TxModeReg,0x0);      //as default???
 372   2                 WriteRawRC(RxModeReg,0x0);      //as default???
 373   2                 WriteRawRC(TxControlReg,0x80);  //as default???
 374   2      
 375   2                 WriteRawRC(TxSelReg,0x10);      //as default???
 376   2         */
 377   2             WriteRawRC(RxSelReg,0x86);//84
 378   2       //      WriteRawRC(RxThresholdReg,0x84);//as default
 379   2       //      WriteRawRC(DemodReg,0x4D);      //as default
 380   2      
 381   2       //      WriteRawRC(ModWidthReg,0x13);//26
 382   2             WriteRawRC(RFCfgReg,0x7F);   //4F
 383   2              /*   WriteRawRC(GsNReg,0x88);        //as default???
 384   2                 WriteRawRC(CWGsCfgReg,0x20);    //as default???
 385   2             WriteRawRC(ModGsCfgReg,0x20);   //as default???
 386   2      */
 387   2                 WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec) 
 388   2                 WriteRawRC(TReloadRegH,0);
 389   2             WriteRawRC(TModeReg,0x8D);
 390   2                 WriteRawRC(TPrescalerReg,0x3E);
 391   2                 
 392   2      
 393   2        //     PcdSetTmo(106);
 394   2                              delay_10ms(1);
 395   2             PcdAntennaOn();
 396   2         }
 397   1         else{ return -1; }
 398   1         
 399   1         return MI_OK;
 400   1      }
 401          /////////////////////////////////////////////////////////////////////
 402          //功    能：读RC632寄存器
 403          //参数说明：Address[IN]:寄存器地址
 404          //返    回：读出的值
 405          /////////////////////////////////////////////////////////////////////
 406          unsigned char ReadRawRC(unsigned char Address)
 407          {
 408   1           unsigned char i, ucAddr;
 409   1           unsigned char ucResult=0;
 410   1      
 411   1           MF522_SCK = 0;
 412   1           MF522_NSS = 0;
 413   1           ucAddr = ((Address<<1)&0x7E)|0x80;
 414   1      
 415   1           for(i=8;i>0;i--)
 416   1           {
 417   2               MF522_SI = ((ucAddr&0x80)==0x80);
 418   2               MF522_SCK = 1;
 419   2               ucAddr <<= 1;
 420   2               MF522_SCK = 0;
 421   2           }
 422   1      
 423   1           for(i=8;i>0;i--)
 424   1           {
 425   2               MF522_SCK = 1;
 426   2               ucResult <<= 1;
C51 COMPILER V9.53.0.0   RC522                                                             07/16/2017 23:21:50 PAGE 8   

 427   2               ucResult|=(bit)MF522_SO;
 428   2               MF522_SCK = 0;
 429   2           }
 430   1      
 431   1           MF522_NSS = 1;
 432   1           MF522_SCK = 1;
 433   1           return ucResult;
 434   1      }
 435          
 436          /////////////////////////////////////////////////////////////////////
 437          //功    能：写RC632寄存器
 438          //参数说明：Address[IN]:寄存器地址
 439          //          value[IN]:写入的值
 440          /////////////////////////////////////////////////////////////////////
 441          void WriteRawRC(unsigned char Address, unsigned char value)
 442          {  
 443   1          unsigned char i, ucAddr;
 444   1      
 445   1          MF522_SCK = 0;
 446   1          MF522_NSS = 0;
 447   1          ucAddr = ((Address<<1)&0x7E);
 448   1      
 449   1          for(i=8;i>0;i--)
 450   1          {
 451   2              MF522_SI = ((ucAddr&0x80)==0x80);
 452   2              MF522_SCK = 1;
 453   2              ucAddr <<= 1;
 454   2              MF522_SCK = 0;
 455   2          }
 456   1      
 457   1          for(i=8;i>0;i--)
 458   1          {
 459   2              MF522_SI = ((value&0x80)==0x80);
 460   2              MF522_SCK = 1;
 461   2              value <<= 1;
 462   2              MF522_SCK = 0;
 463   2          }
 464   1          MF522_NSS = 1;
 465   1          MF522_SCK = 1;
 466   1      }
 467          
 468          /////////////////////////////////////////////////////////////////////
 469          //功    能：置RC522寄存器位
 470          //参数说明：reg[IN]:寄存器地址
 471          //          mask[IN]:置位值
 472          /////////////////////////////////////////////////////////////////////
 473          void SetBitMask(unsigned char reg,unsigned char mask)  
 474          {
 475   1          char tmp = 0x0;
 476   1          tmp = ReadRawRC(reg);
 477   1          WriteRawRC(reg,tmp | mask);  // set bit mask
 478   1      }
 479          
 480          /////////////////////////////////////////////////////////////////////
 481          //功    能：清RC522寄存器位
 482          //参数说明：reg[IN]:寄存器地址
 483          //          mask[IN]:清位值
 484          /////////////////////////////////////////////////////////////////////
 485          void ClearBitMask(unsigned char reg,unsigned char mask)  
 486          {
 487   1          char tmp = 0x0;
 488   1          tmp = ReadRawRC(reg);
C51 COMPILER V9.53.0.0   RC522                                                             07/16/2017 23:21:50 PAGE 9   

 489   1          WriteRawRC(reg, tmp & ~mask);  // clear bit mask
 490   1      } 
 491          
 492          /////////////////////////////////////////////////////////////////////
 493          //功    能：通过RC522和ISO14443卡通讯
 494          //参数说明：Command[IN]:RC522命令字
 495          //          pInData[IN]:通过RC522发送到卡片的数据
 496          //          InLenByte[IN]:发送数据的字节长度
 497          //          pOutData[OUT]:接收到的卡片返回数据
 498          //          *pOutLenBit[OUT]:返回数据的位长度
 499          /////////////////////////////////////////////////////////////////////
 500          char PcdComMF522(unsigned char Command, 
 501                           unsigned char *pInData, 
 502                           unsigned char InLenByte,
 503                           unsigned char *pOutData, 
 504                           unsigned int  *pOutLenBit)
 505          {
 506   1          char status = MI_ERR;
 507   1          unsigned char irqEn   = 0x00;
 508   1          unsigned char waitFor = 0x00;
 509   1          unsigned char lastBits;
 510   1          unsigned char n;
 511   1          unsigned int i;
 512   1          switch (Command)
 513   1          {
 514   2             case PCD_AUTHENT:
 515   2                irqEn   = 0x12;
 516   2                waitFor = 0x10;
 517   2                break;
 518   2             case PCD_TRANSCEIVE:
 519   2                irqEn   = 0x77;
 520   2                waitFor = 0x30;
 521   2                break;
 522   2             default:
 523   2               break;
 524   2          }
 525   1         
 526   1          WriteRawRC(ComIEnReg,irqEn|0x80);
 527   1          ClearBitMask(ComIrqReg,0x80);
 528   1          WriteRawRC(CommandReg,PCD_IDLE);
 529   1          SetBitMask(FIFOLevelReg,0x80);
 530   1          
 531   1          for (i=0; i<InLenByte; i++)
 532   1          {   WriteRawRC(FIFODataReg, pInData[i]);    }
 533   1          WriteRawRC(CommandReg, Command);
 534   1         
 535   1          
 536   1          if (Command == PCD_TRANSCEIVE)
 537   1          {    SetBitMask(BitFramingReg,0x80);  }
 538   1          
 539   1      //    i = 600;//根据时钟频率调整，操作M1卡最大等待时间25ms
 540   1       i = 2000;
 541   1          do 
 542   1          {
 543   2               n = ReadRawRC(ComIrqReg);
 544   2               i--;
 545   2          }
 546   1          while ((i!=0) && !(n&0x01) && !(n&waitFor));
 547   1          ClearBitMask(BitFramingReg,0x80);
 548   1                    
 549   1          if (i!=0)
 550   1          {    
C51 COMPILER V9.53.0.0   RC522                                                             07/16/2017 23:21:50 PAGE 10  

 551   2               if(!(ReadRawRC(ErrorReg)&0x1B))
 552   2               {
 553   3                   status = MI_OK;
 554   3                   if (n & irqEn & 0x01)
 555   3                   {   status = MI_NOTAGERR;   }
 556   3                   if (Command == PCD_TRANSCEIVE)
 557   3                   {
 558   4                      n = ReadRawRC(FIFOLevelReg);
 559   4                      lastBits = ReadRawRC(ControlReg) & 0x07;
 560   4                      if (lastBits)
 561   4                      {   *pOutLenBit = (n-1)*8 + lastBits;   }
 562   4                      else
 563   4                      {   *pOutLenBit = n*8;   }
 564   4                      if (n == 0)
 565   4                      {   n = 1;    }
 566   4                      if (n > MAXRLEN)
 567   4                      {   n = MAXRLEN;   }
 568   4                      for (i=0; i<n; i++)
 569   4                      {   pOutData[i] = ReadRawRC(FIFODataReg);    }
 570   4                  }
 571   3               }
 572   2               else
 573   2               {   status = MI_ERR;   }
 574   2              
 575   2         }
 576   1         
 577   1      
 578   1         SetBitMask(ControlReg,0x80);           // stop timer now
 579   1         WriteRawRC(CommandReg,PCD_IDLE); 
 580   1         return status;
 581   1      }
 582          
 583          
 584          /////////////////////////////////////////////////////////////////////
 585          //开启天线  
 586          //每次启动或关闭天险发射之间应至少有1ms的间隔
 587          /////////////////////////////////////////////////////////////////////
 588          void PcdAntennaOn()
 589          {
 590   1          unsigned char i;
 591   1          i = ReadRawRC(TxControlReg);
 592   1          if (!(i & 0x03))
 593   1          {
 594   2              SetBitMask(TxControlReg, 0x03);
 595   2          }
 596   1      }
 597          
 598          
 599          /////////////////////////////////////////////////////////////////////
 600          //关闭天线
 601          /////////////////////////////////////////////////////////////////////
 602          void PcdAntennaOff()
 603          {
 604   1          ClearBitMask(TxControlReg, 0x03);
 605   1      }
 606          
 607          
 608          /////////////////////////////////////////////////////////////////////
 609          //功    能：扣款和充值
 610          //参数说明: dd_mode[IN]：命令字
 611          //               0xC0 = 扣款
 612          //               0xC1 = 充值
C51 COMPILER V9.53.0.0   RC522                                                             07/16/2017 23:21:50 PAGE 11  

 613          //          addr[IN]：钱包地址
 614          //          pValue[IN]：4字节增(减)值，低位在前
 615          //返    回: 成功返回MI_OK
 616          /////////////////////////////////////////////////////////////////////                 
 617          /*char PcdValue(unsigned char dd_mode,unsigned char addr,unsigned char *pValue)
 618          {
 619              char status;
 620              unsigned int  unLen;
 621              unsigned char ucComMF522Buf[MAXRLEN]; 
 622              
 623              ucComMF522Buf[0] = dd_mode;
 624              ucComMF522Buf[1] = addr;
 625              CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 626           
 627              status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 628          
 629              if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
 630              {   status = MI_ERR;   }
 631                  
 632              if (status == MI_OK)
 633              {
 634                  memcpy(ucComMF522Buf, pValue, 4);
 635           //       for (i=0; i<16; i++)
 636           //       {    ucComMF522Buf[i] = *(pValue+i);   }
 637                  CalulateCRC(ucComMF522Buf,4,&ucComMF522Buf[4]);
 638                  unLen = 0;
 639                  status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,6,ucComMF522Buf,&unLen);
 640                  if (status != MI_ERR)
 641                  {    status = MI_OK;    }
 642              }
 643              
 644              if (status == MI_OK)
 645              {
 646                  ucComMF522Buf[0] = PICC_TRANSFER;
 647                  ucComMF522Buf[1] = addr;
 648                  CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]); 
 649             
 650                  status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 651          
 652                  if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
 653                  {   status = MI_ERR;   }
 654              }
 655              return status;
 656          }
 657          
 658          /////////////////////////////////////////////////////////////////////
 659          //功    能：备份钱包
 660          //参数说明: sourceaddr[IN]：源地址
 661          //          goaladdr[IN]：目标地址
 662          //返    回: 成功返回MI_OK
 663          /////////////////////////////////////////////////////////////////////
 664          char PcdBakValue(unsigned char sourceaddr, unsigned char goaladdr)
 665          {
 666              char status;
 667              unsigned int  unLen;
 668              unsigned char ucComMF522Buf[MAXRLEN]; 
 669          
 670              ucComMF522Buf[0] = PICC_RESTORE;
 671              ucComMF522Buf[1] = sourceaddr;
 672              CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 673           
 674              status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
C51 COMPILER V9.53.0.0   RC522                                                             07/16/2017 23:21:50 PAGE 12  

 675          
 676              if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
 677              {   status = MI_ERR;   }
 678              
 679              if (status == MI_OK)
 680              {
 681                  ucComMF522Buf[0] = 0;
 682                  ucComMF522Buf[1] = 0;
 683                  ucComMF522Buf[2] = 0;
 684                  ucComMF522Buf[3] = 0;
 685                  CalulateCRC(ucComMF522Buf,4,&ucComMF522Buf[4]);
 686           
 687                  status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,6,ucComMF522Buf,&unLen);
 688                  if (status != MI_ERR)
 689                  {    status = MI_OK;    }
 690              }
 691              
 692              if (status != MI_OK)
 693              {    return MI_ERR;   }
 694              
 695              ucComMF522Buf[0] = PICC_TRANSFER;
 696              ucComMF522Buf[1] = goaladdr;
 697          
 698              CalulateCRC(ucComMF522Buf,2,&ucComMF522Buf[2]);
 699           
 700              status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,4,ucComMF522Buf,&unLen);
 701          
 702              if ((status != MI_OK) || (unLen != 4) || ((ucComMF522Buf[0] & 0x0F) != 0x0A))
 703              {   status = MI_ERR;   }
 704          
 705              return status;
 706          }                                       */
 707                  
 708          /*************************************************************
 709          函数名称writePassword
 710          参数index 指定数据存储的扇区号   取值范围0-15
 711          功能 把dat存储到index指定的块中
 712          **************************************************************/
 713          unsigned char writePassword(unsigned char *cardKey,unsigned char index,unsigned char *dat) 
 714          {
 715   1              unsigned char xdata cardTyp[2];
 716   1              unsigned char xdata cardNum[4];
 717   1              unsigned char xdata cardSize=0;
 718   1              PcdAntennaOff(); 
 719   1              delay_10ms(100);
 720   1              PcdAntennaOn();
 721   1              delay_10ms(100);
 722   1              //cardtypstu=;                          //寻卡
 723   1              if(PcdRequest(0x52,cardTyp)==MI_OK)       // 如果寻卡成功
 724   1              {        //return 1;
 725   2                      if(PcdAnticoll(cardNum)==MI_OK)                                 //获取卡的卡号防冲突
 726   2                      {
 727   3                               if(PcdSelect(cardNum,&cardSize)==MI_OK)                //选卡并返回卡容量
 728   3                               {
 729   4                                      if(cardSize<8)
 730   4                                              return MI_WR_ERR;
 731   4                               }
 732   3                               else
 733   3                                      return MI_WR_ERR;
 734   3                                              
 735   3                               if(PcdAuthState(PICC_AUTHENT1A,index*4+3,cardKey,cardNum)==MI_OK)
 736   3                               {
C51 COMPILER V9.53.0.0   RC522                                                             07/16/2017 23:21:50 PAGE 13  

 737   4                                        if(PcdWrite(index*4+3,dat)==MI_OK )
 738   4                                                return MI_WR_OK;
 739   4                                        else
 740   4                                                return MI_WR_ERR;
 741   4                               }
 742   3                               else
 743   3                                      return MI_WR_ERR;
 744   3                      }
 745   2                      else
 746   2                              return MI_WR_ERR;
 747   2      
 748   2              }
 749   1              else
 750   1                      return MI_WR_ERR;
 751   1      }
 752          
 753          
 754          
 755          /*************************************************************
 756          函数名称readDataFromIc
 757          参数index 指定数据存储的块序号   取值范围0-46
 758          功能 把index指定的数据存储到dat中
 759          **************************************************************/
 760          unsigned char readDataFromIc(unsigned char *cardKey,unsigned char index,unsigned char *dat) 
 761          {
 762   1              unsigned char xdata cardTyp[2];
 763   1              unsigned char xdata cardNum[4];
 764   1              unsigned char xdata cardSize=0;
 765   1              PcdAntennaOff(); 
 766   1              delay_10ms(100);
 767   1              PcdAntennaOn();
 768   1              delay_10ms(100);
 769   1              //cardtypstu=;                          //寻卡
 770   1              if(PcdRequest(0x52,cardTyp)==MI_OK)       // 如果寻卡成功
 771   1              {        //return 1;
 772   2                      if(PcdAnticoll(cardNum)==MI_OK)                                 //获取卡的卡号防冲突
 773   2                      {
 774   3                               if(PcdSelect(cardNum,&cardSize)==MI_OK)                //选卡并返回卡容量
 775   3                               {
 776   4                                      if(cardSize<8)
 777   4                                              return MI_RD_ERR;
 778   4                               }
 779   3                               else
 780   3                                      return MI_RD_ERR;
 781   3      
 782   3                      
 783   3                               if(PcdAuthState(PICC_AUTHENT1A,blockIdToIndex[index],cardKey,cardNum)==MI_OK)
 784   3                               {
 785   4                                        if(PcdRead(blockIdToIndex[index],dat)==MI_OK )
 786   4                                                return MI_RD_OK;
 787   4                                        else
 788   4                                                return MI_RD_ERR ;
 789   4                               }
 790   3                               else
 791   3                                      return MI_RD_ERR;
 792   3                      }
 793   2                      else
 794   2                              return MI_RD_ERR;
 795   2              }
 796   1              else
 797   1                      return MI_RD_ERR;
 798   1      }
C51 COMPILER V9.53.0.0   RC522                                                             07/16/2017 23:21:50 PAGE 14  

 799          /*************************************************************
 800          函数名称writeDataToIc
 801          参数index 指定数据存储的块序号   取值范围0-46
 802          功能 把dat指定的数据存储到ic卡的index块中
 803          **************************************************************/
 804          unsigned char writeDataToIc(unsigned char *cardKey,unsigned char index,unsigned char *dat) 
 805          {
 806   1              unsigned char xdata cardTyp[2];
 807   1              unsigned char xdata cardNum[4];
 808   1              unsigned char xdata cardSize=0;
 809   1              //cardtypstu=;                          //寻卡
 810   1              unsigned char xdata status=0;
 811   1              unsigned int xdata  count=0;
 812   1              PcdAntennaOff(); 
 813   1              delay_10ms(100);
 814   1              PcdAntennaOn();
 815   1              delay_10ms(100);
 816   1              /*while(1)
 817   1              {
 818   1                      switch (status)
 819   1                      {
 820   1                      case 0:
 821   1                              if(PcdRequest(0x52,cardTyp)==MI_OK)       // 如果寻卡成功
 822   1                              {
 823   1                                      status=1;
 824   1                                      count=0;
 825   1                              }
 826   1                      break;
 827   1                      case 1:
 828   1                              if(PcdAnticoll(cardNum)==MI_OK)                                 //获取卡的卡号防冲突
 829   1                              {
 830   1                                      status=2;count=0;
 831   1                              }
 832   1                              else
 833   1                              {
 834   1                                      status=0;
 835   1                              }
 836   1                      break;
 837   1                      case 2:
 838   1                              if(PcdSelect(cardNum,&cardSize)==MI_OK)         //选卡并返回卡容量
 839   1                               {
 840   1                                      if(cardSize<8)
 841   1                                              return MI_WR_ERR;
 842   1                               }
 843   1                               if(PcdAuthState(PICC_AUTHENT1A,blockIdToIndex[index],cardKey,cardNum)==MI_OK)
 844   1                               {
 845   1                                      status=3;count=0;
 846   1                               }
 847   1                               else
 848   1                               {
 849   1                                      status=0;
 850   1                               }
 851   1                      break;
 852   1      
 853   1                      case 3:
 854   1                              if(PcdWrite(blockIdToIndex[index],dat)==MI_OK)
 855   1                                        {
 856   1                                            status=0;count=0;
 857   1                                                return MI_WR_OK;
 858   1                                        }
 859   1                              else
 860   1                              {status=0;}
C51 COMPILER V9.53.0.0   RC522                                                             07/16/2017 23:21:50 PAGE 15  

 861   1                      break;
 862   1                      }
 863   1                      count++;
 864   1                      if(count>50)return MI_WR_ERR;
 865   1              }        */
 866   1              if(PcdRequest(0x52,cardTyp)==MI_OK)       // 如果寻卡成功
 867   1              {
 868   2                      if(PcdAnticoll(cardNum)==MI_OK)                                 //获取卡的卡号防冲突
 869   2                      {
 870   3                               if(PcdSelect(cardNum,&cardSize)==MI_OK)                //选卡并返回卡容量
 871   3                               {
 872   4                                      if(cardSize<8)
 873   4                                              return MI_WR_ERR;
 874   4                               }
 875   3                               else
 876   3                                      return MI_WR_ERR;
 877   3                              
 878   3                               if(PcdAuthState(PICC_AUTHENT1A,blockIdToIndex[index],cardKey,cardNum)==MI_OK)
 879   3                               {
 880   4                                        if(PcdWrite(blockIdToIndex[index],dat)==MI_OK)
 881   4                                                return MI_WR_OK;
 882   4                                        else
 883   4                                                return MI_WR_ERR ;
 884   4                               }
 885   3                               else
 886   3                                      return MI_WR_ERR;
 887   3                      }
 888   2                      else
 889   2                              return MI_WR_ERR;
 890   2              }
 891   1              else
 892   1                      return MI_WR_ERR;
 893   1      }
 894             
 895          
 896          ///////////////////////////////////////////////////////////////////////
 897          // Delay 10ms
 898          ///////////////////////////////////////////////////////////////////////
 899          /*void delay_10ms(unsigned int _10ms)
 900          {
 901          #ifndef NO_TIMER2
 902              RCAP2LH = RCAP2_10ms;
 903              T2LH    = RCAP2_10ms;
 904              
 905              TR2 = TRUE;
 906              while (_10ms--)
 907              {
 908                      while (!TF2);
 909                      TF2 = FALSE;
 910              }
 911              TR2 = FALSE;
 912          #else
 913              while (_10ms--)
 914              {
 915                      delay_50us(19);
 916                      if (CmdValid)
 917                          return;
 918                      delay_50us(20);
 919                      if (CmdValid)
 920                          return;
 921                      delay_50us(20);
 922                      if (CmdValid)
C51 COMPILER V9.53.0.0   RC522                                                             07/16/2017 23:21:50 PAGE 16  

 923                          return;
 924                      delay_50us(20);
 925                      if (CmdValid)
 926                          return;
 927                      delay_50us(20);
 928                      if (CmdValid )
 929                          return;
 930                      delay_50us(20);
 931                      if (CmdValid)
 932                          return;
 933                      delay_50us(20);
 934                      if (CmdValid)
 935                          return;
 936                      delay_50us(20);
 937                      if (CmdValid)
 938                          return;
 939                      delay_50us(20);
 940                      if (CmdValid)
 941                          return;
 942                      delay_50us(19);
 943                      if (CmdValid)
 944                          return;
 945              }
 946          #endif
 947          }                                                                               */
 948          
 949          
 950          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2040    ----
   CONSTANT SIZE    =     66    ----
   XDATA SIZE       =   ----      24
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----     196
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
