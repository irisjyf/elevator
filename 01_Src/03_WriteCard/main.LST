C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\04_bin\WriteCard\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND OBJECT(..\04_bin\Writ
                    -eCard\main.obj)

line level    source

   1                    
   2          /*********************************************************/
   3          //Í·ÎÄ¼þ
   4          #include <intrins.h>
   5          #include <string.h>
   6          #include "STC15Fxxxx.h"
   7          #include "Time.h"
   8          #include "EEPROM.h"
   9          #include "io.h"
  10          #include "HYM8563.H"
  11          #include "mfrc522.h"
  12          #include "cc1101.h"
  13          #include "api.h"
  14          
  15          #define  BUFINLEN 90
  16          
  17          
  18          //#define WRITE_TYPE 0x01
  19          //#define READ_TYPE 0x02
  20          //#define USER_TYPE 0x03
  21          //#define MGRE_TYPE 0x04
  22          //#define FUNC_TYPE 0x05
  23          
  24          //#define SERI_TYPE 0x06 //ÐòÁÐºÅ
  25          
  26          #define IC_CMD_WRITE            0x01
  27          #define IC_CMD_READ                     0x02
  28          #define IC_CMD_CUSTOMER         0x03
  29          #define IC_CMD_MANAGER          0x04
  30          #define IC_CMD_FUNC                     0x05
  31          #define IC_CMD_MODIFY_TIME      0x07
  32          #define IC_CMD_GET_TIME         0x08
  33          #define IC_CMD_AGENT            0x09
  34          #define IC_CMD_PRODUCT          0x0A
  35          #define IC_CMD_OFFSET           0x0B
  36          #define IC_CMD_GETSERIAL        0x0C
  37          #define IC_CMD_GET_CHECK        0x0D
  38          #define IC_CMD_TEST                     0x0E
  39          
  40          
  41          #define STOP_PRODUCE_CMD                0x00
  42          #define START_PRODUCE_CMD               0x01
  43          #define ENABLE_PRODUCE_VERITY   0x02
  44          #define DISABLE_PRODUCE_VERITY  0x03
  45          #define WRITE_PRODUCE_PSW               0x04
  46          #define READ_PRODUCE_PSW                0x05
  47          
  48          
  49          #define FUNC_TYPE_FORBIDEN              0x01
  50          #define FUNC_TYPE_CHECK_TIME    0x02
  51          #define FUNC_TYPE_SWITCH                0x03
  52          #define FUNC_TYPE_OFFSET                0x04
  53          #define FUNC_TYPE_AGENT                 0x05
  54          #define FUNC_TYPE_Check                 0x06
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 2   

  55          #define FUNC_TYPE_CLEARBLACKLIST                0x07
  56          
  57          
  58          
  59          sbit LED =P5^4;
  60          sbit FMQ =P0^5;
  61          
  62          #define FOSC  11059200L
  63          #define BAUD  9600
  64          #define TM      (65536-(FOSC/4/BAUD))
  65          
  66          #define LEDOFF {LED=1;FMQ=0;}
  67          #define LEDON {LED=0;FMQ=1;}
  68          
  69          #define FMQON   {FMQ=1;}
  70          #define FMQOFF  {FMQ=0;}
  71          
  72          
  73          #define TIMEOUT           -1
  74          #define TIMEOUT_ALL           5
  75          #define CC1101            0X00
  76          #define BT_UART           0X01
  77          #define MSG_OPEN          0X01
  78          #define MSG_CLOSE         0X02
  79          #define MSG_OBTAIN_STATUS 0X03
  80          
  81          #define READ            0x01
  82          #define WRITE           0x02
  83          
  84          
  85          unsigned char xdata sendnum;
  86          unsigned char xdata cardtyp[2];
  87          unsigned char xdata cardnum[4];
  88          unsigned char xdata cardsize[1];
  89          unsigned char xdata cardkey[6]                  ={0xff,0xff,0xff,0xff,0xff,0xff};//0x01,0x02,0x03,0x04,0x05,0x06
  90          unsigned char xdata newkey[16]                  ={0xff,0xff,0xff,0xff,0xff,0xff,0xFF,0x07,0x80,0x69,0xFF,0xFF,0xFF,0xFF,0
             -xFF,0xFF};
  91          unsigned char xdata card_new_key[16]    ={0xff,0xff,0xff,0xff,0xff,0xff,0xFF,0x07,0x80,0x69,0xFF,0xFF,0xFF,0x
             -FF,0xFF,0xFF};
  92          unsigned char xdata Password_Data[4]    ={0xff,0xff,0xff,0xff};
  93          
  94          unsigned char xdata cardknum[16];
  95          //unsigned char xdata cardwdata[16]={0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x10,0x11,0x12,0x13,0x17
             -,0x15,0x16};
  96          //unsigned char xdata cardwdata[16]={0xff,0xff,0xff,0xff,0xff,0xff,0xFF,0x07,0x80,0x69,0xFF,0xFF,0xFF,0xFF
             -,0xFF,0xFF};
  97          //unsigned char xdata timere=0;
  98          //unsigned char xdata timecard=510;
  99          unsigned char xdata *p;
 100          
 101          char xdata cardtypstu;
 102          char xdata cardnumstu;
 103          char xdata cardsizestu;
 104          char xdata cardcheckstu;
 105          char xdata cardknumstu;
 106          char xdata cardwdatastu;
 107          
 108          unsigned char xdata bufini=0,bufino;
 109          unsigned char xdata maincmd[BUFINLEN];
 110          unsigned char xdata bt_data[BUFINLEN];
 111          unsigned int idata counter2=0;
 112          
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 3   

 113          bit  idata internal2=0;
 114          unsigned char xdata g_chPackageFlag = 0; 
 115          unsigned char xdata g_chOffsetSecton = 0;
 116          
 117          unsigned char xdata g_chProduceFlag = 0;
 118          unsigned char xdata g_chVerifyProduceFlag = 0;
 119          unsigned char xdata g_chVerifyAgentFlag = 0;
 120          unsigned char xdata g_chPasswordFlag = 0;
 121          unsigned char xdata g_chReversCheckFlag = 0;
 122          unsigned long xdata g_ulAgentID = 0xffffffff;
 123          unsigned char xdata chAgentIDBuf[4];
 124          
 125          uchar *pp2;
 126          unsigned char xdata bt_buf[BUFINLEN];
 127          
 128          void UART_init (void)
 129          {
 130   1              //EA = 1; //ÔÊÐí×ÜÖÐ¶Ï£¨Èç²»Ê¹ÓÃÖÐ¶Ï£¬¿ÉÓÃ//ÆÁ±Î£©
 131   1              
 132   1              SCON=0x50;
 133   1              
 134   1      //      S2CON=0x50;             //8Î»Êý¾Ý,¿É±ä²¨ÌØÂÊ
 135   1      //      AUXR |= 0x04;           //¶¨Ê±Æ÷2Ê±ÖÓÎªFosc,¼´1T
 136   1              
 137   1              T2L = TM;               //Éè¶¨¶¨Ê±³õÖµ
 138   1              T2H = TM>>8;            //Éè¶¨¶¨Ê±³õÖµ
 139   1              
 140   1              //RL_T2H=0XAA;
 141   1              //RL_T2L=0XFA;
 142   1              
 143   1              AUXR |= 0x01;           //´®¿Ú1Ñ¡Ôñ¶¨Ê±Æ÷2Îª²¨ÌØÂÊ·¢ÉúÆ÷
 144   1      //      AUXR |= 0x10;           //Æô¶¯¶¨Ê±Æ÷2 
 145   1      //      IE2 |= 1; //ÔÊÐíUART2´®¿ÚµÄÖÐ¶Ï
 146   1              
 147   1              ES = 1; //ÔÊÐíUART1´®¿ÚµÄÖÐ¶Ï
 148   1      }
 149          void Send(uchar *str,uint len)
 150          {
 151   1              pp2 = str;
 152   1              counter2 = len;
 153   1              internal2 = 1;
 154   1              SBUF = *pp2++;
 155   1              while(internal2); 
 156   1      }
 157          
 158          
 159          void Beep(void)
 160          {
 161   1              FMQ=1;
 162   1              Delay1();
 163   1              Delay1();
 164   1              Delay1();
 165   1              FMQ=0;
 166   1              Delay1();
 167   1              Delay1();
 168   1              Delay1();
 169   1      }
 170          
 171          void Flash()
 172          {
 173   1              LED = 1;
 174   1              FMQ = 1;
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 4   

 175   1              Delay1();
 176   1              Delay1();
 177   1              Delay1();
 178   1              FMQ = 0;
 179   1              LED = 0;
 180   1      }
 181          
 182          void Sounds(unsigned long uCount)
 183          {
 184   1              uchar xdata i;
 185   1              for(i=0; i<uCount; i++){
 186   2                      Beep();         
 187   2                      }
 188   1      }
 189          
 190          
 191          //void LongBeep()
 192          //{
 193          //      unsigned char i;
 194          //      FMQON
 195          //      for(i = 0; i < 255; i++)
 196          //                      Delay1();
 197          //      FMQOFF
 198          //}
 199          
 200          void MakeResult(uchar errOkFlag)
 201          {
 202   1              if(errOkFlag == Do_True)
 203   1              {
 204   2                       maincmd[0] = Do_True;
 205   2                       Flash();
 206   2              }
 207   1              else
 208   1              {
 209   2                       maincmd[0] = Do_False;
 210   2                       Sounds(2);
 211   2              }
 212   1      }
 213          
 214          
 215          //
 216          /****************************************
 217          º¯Êý¹¦ÄÜ:½«baoÖÐµÄÊý¾Ý×é°üµ½sendbaoÄÚ´æÖÐ
 218          
 219          *****************************************/
 220          void Make(unsigned char chType,unsigned int len,unsigned char *sendbao)
 221          {
 222   1              uchar xdata i;
 223   1              uint xdata sum;
 224   1      
 225   1              uchar xdata bao[80];
 226   1              sum=0;
 227   1      
 228   1              for(i=0;i < len - 2;i++)                
 229   1              {
 230   2                      bao[i] = sendbao[i];
 231   2              }
 232   1              sendbao[0] = 0xef;
 233   1              sendbao[1] = 0x01;
 234   1      
 235   1              sendbao[2] = chType;
 236   1              sendbao[3] = len >> 8;
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 5   

 237   1              sendbao[4] = len & 0xFF;
 238   1              
 239   1              for(i=0;i < len - 2; i++)
 240   1              {
 241   2                      sendbao[5+i] = bao[i];
 242   2                      sum = sum+bao[i];
 243   2              }
 244   1              
 245   1              sum = sum + len + chType;
 246   1              
 247   1              sendbao[4 + len - 1] = sum >> 8;
 248   1              sendbao[4 + len] = sum & 0xFF;
 249   1      }
 250          
 251          
 252          /****************************************
 253          º¯Êý¹¦ÄÜ£º¿½±´srcÄÚ´æµÄÊý¾Ýµ½ desÄÚ´æÄÚ£¬¿½±´´óÐ¡Îªlen
 254          
 255          *****************************************/
 256          
 257          //void memcopy(unsigned char *des,unsigned char *src,unsigned char len)
 258          //{
 259          //      unsigned char i ;
 260          //      for(i=0;i<len;i++)
 261          //      {
 262          //              *des++=*src++;
 263          //      }
 264          //      if(len<16)
 265          //      for(i=len;i<16;i++)
 266          //              *des=0; 
 267          //}
 268          
 269          
 270          //»ñÈ¡¿¨µÄÐòÁÐºÅ
 271          uchar GetCardSerial(uchar* ucSerial, uchar ucLength)
 272          {
 273   1              uchar xdata ucRet = MI_ERR;
 274   1              if(ucLength < 4 || NULL == ucSerial)
 275   1                      return Do_False;
 276   1              
 277   1              ucRet = PcdRequest(0x52, cardtyp);                              //Ñ°¿¨
 278   1              if(ucRet != MI_OK)
 279   1              {       
 280   2                      ucRet = PcdRequest(0x52, cardtyp);
 281   2                      if(ucRet != MI_OK)
 282   2                      {
 283   3                              return Do_False;
 284   3                      }
 285   2              }       
 286   1              ucRet = PcdAnticoll(ucSerial);                                  //»ñÈ¡¿¨µÄ¿¨ºÅ
 287   1              
 288   1              if(ucRet != MI_OK)
 289   1                      return Do_False;
 290   1              return Do_True;
 291   1      }
 292          
 293          
 294          ///////////////////////////////////////////////////////////////////////////////////////
 295          ///////////
 296          ///////////     ¼ÆËãÃ¿¸öÉÈÇøºÅÓë¿éºÅµÄ¶ÔÓ¦¹ØÏµ,±¾´¦ËùÓÃ·Ç¾ø¶Ô¶ÔµØÖ·¿é/////////////////////
 297          ///////////     Èë¿Ú:  Ã¿¸öÉÈÇø¶ÔÓ¦µÄ¿éºÅ,·¶Î§:¿é0~¿é3
 298          //////////////////////////////////////////////////////////////////////////////////////
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 6   

 299          
 300          
 301          uchar GeneratePsw(void)     //ÃÜÔ¿´¦Àíº¯Êý Ò»¿¨Ò»ÃÜÔ¿£¬²»Í¬ÉÈÇø²»ÃÜÔ¿Ò²²»Í¬
 302          {
 303   1              uchar xdata i;
 304   1              uchar xdata ucRet = 0;
 305   1              uchar xdata ucCardSerial[4] = {0};
 306   1      
 307   1              for(i = 0; i < 4; i++)
 308   1                      card_new_key[1 + i] = Password_Data[i];  //cardwdata ¶¨ÒåÃÜÔ¿ÔÝ´æÊý×é ³¤¶È6¸ö×Ö½Ú  £¬chData ´æ·ÅÐòÁÐºÅµÄ
             -£¬ÐòÁÐºÅÎª4¸ö×Ö½Ú
 309   1      
 310   1              //card_new_key[0] = 0xFF;               //Õâ¸öÖµÄã¿É×Ô¼º¶¨Òå
 311   1              //card_new_key[5] = 0xFF;                       //Õâ¸öÖµÊÇ¿éºÅ £¬¼´Ã¿¸öÉÈÇøµÄ¿ØÖÆ¿éºÅÖµÊÇ²»Í¬µÄ         
 312   1              
 313   1              memcpy(newkey,card_new_key,16);
 314   1              
 315   1              return Do_True;
 316   1      }
 317          
 318          
 319          uchar RecoverPsw()     //ÃÜÔ¿´¦Àíº¯Êý Ò»¿¨Ò»ÃÜÔ¿£¬²»Í¬ÉÈÇø²»ÃÜÔ¿Ò²²»Í¬
 320          {
 321   1              uchar xdata i;
 322   1      
 323   1              for(i = 0; i < 4; i++)
 324   1                      card_new_key[1 + i] = 0xFF;  //cardwdata ¶¨ÒåÃÜÔ¿ÔÝ´æÊý×é ³¤¶È6¸ö×Ö½Ú  £¬chData ´æ·ÅÐòÁÐºÅµÄ£¬ÐòÁÐºÅÎª4¸
             -ö×Ö½Ú
 325   1      
 326   1              //card_new_key[0] = 0xFF;               //Õâ¸öÖµÄã¿É×Ô¼º¶¨Òå
 327   1              //card_new_key[5] = 0xFF;                       //Õâ¸öÖµÊÇ¿éºÅ £¬¼´Ã¿¸öÉÈÇøµÄ¿ØÖÆ¿éºÅÖµÊÇ²»Í¬µÄ         
 328   1              
 329   1              memcpy(newkey,card_new_key,16);
 330   1              
 331   1              return Do_True;
 332   1      }
 333          
 334          unsigned char GetCommand(unsigned char chType,unsigned char*bufino,unsigned char bufini)
 335          {
 336   1              unsigned char xdata *combuf,*dat;
 337   1              unsigned char xdata i,j,len2,k;
 338   1              unsigned int xdata crc;
 339   1              
 340   1              if(chType == BT_UART)
 341   1              {
 342   2                      combuf =bt_buf;
 343   2                      dat =bt_data;
 344   2              }
 345   1              
 346   1              i = *bufino;
 347   1              
 348   1      rescan1:
 349   1              if(bufini==i) 
 350   1                      return 0;
 351   1              
 352   1              if((combuf[i++])!=0xef) 
 353   1              {
 354   2                      if(i >= BUFINLEN) 
 355   2                              i = 0;  
 356   2                      *bufino = i; 
 357   2                      goto rescan1;
 358   2              }
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 7   

 359   1              if(i >= BUFINLEN) 
 360   1                      i = 0;
 361   1              if(bufini == i) 
 362   1                      return 0;
 363   1              if((combuf[i++])!=0x01) 
 364   1              {
 365   2                      if(i >= BUFINLEN) 
 366   2                              i = 0; 
 367   2                      *bufino = i; 
 368   2                      goto rescan1;
 369   2              }
 370   1              if(i >= BUFINLEN) 
 371   1                      i=0;
 372   1              
 373   1              if(bufini == i) 
 374   1                      return 0;
 375   1                      
 376   1              g_chPackageFlag = combuf[i++];
 377   1              
 378   1              if(i >= BUFINLEN) 
 379   1                      i = 0;
 380   1              
 381   1              if(bufini == i) 
 382   1                      return 0;
 383   1      
 384   1              i++; 
 385   1              
 386   1              if(i >= BUFINLEN) 
 387   1                      i=0;
 388   1              if(bufini==i) 
 389   1                      return 0;
 390   1      
 391   1              len2=combuf[i++]; 
 392   1              
 393   1              if(i>=BUFINLEN) 
 394   1                      i=0;
 395   1              if(bufini==i) 
 396   1                      return 0;
 397   1      
 398   1      //      len0=len1*256+len2;
 399   1              if(len2<=2||len2>=200) 
 400   1              {
 401   2                      *bufino=i; 
 402   2                      goto rescan1;
 403   2              } 
 404   1      
 405   1              crc = g_chPackageFlag + len2;
 406   1              j=0;
 407   1              
 408   1              while(len2-2)
 409   1              {
 410   2                      if(bufini==i) 
 411   2                              return 0;
 412   2                      k = dat[j++] = combuf[i++];
 413   2                      
 414   2                      if(i >= BUFINLEN) 
 415   2                              i=0;
 416   2                      crc += k;
 417   2                      len2--;
 418   2              }
 419   1              if(bufini == i) 
 420   1                      return 0;
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 8   

 421   1              crc -= (unsigned int) combuf[i++]*256;
 422   1              
 423   1              if(i>=BUFINLEN) 
 424   1                      i=0;    
 425   1              if(bufini == i) 
 426   1                      return 0;
 427   1              
 428   1              crc -= combuf[i++];
 429   1              
 430   1              if(i >= BUFINLEN) 
 431   1                      i = 0;
 432   1      
 433   1              if(crc) 
 434   1              {
 435   2                      *bufino=i; 
 436   2                      //Sounds(2);
 437   2                      //maincmd[0] = crc % 255;
 438   2                      //Make(9,4,maincmd);
 439   2                      //Send(maincmd, 9);
 440   2                      goto rescan1;
 441   2              }
 442   1              else
 443   1              {
 444   2                      *bufino=i; 
 445   2                      return 1;
 446   2              }
 447   1      }
 448          
 449          
 450          /****************************************
 451          º¯Êý¹¦ÄÜ:
 452                  ¶Á¹¦ÄÜ¿¨£¬½«Êý¾Ý±£´æµ½maincmdÖÐ
 453          ÃèÊö:
 454          
 455          ¶Á¿¨ÉÈÇø0~~~~7ÖÐµÄÊý¾Ý£¬
 456          ²¢±¨Êý¾Ý±£´æµ½maincmd ÖÐ
 457          ·µ»ØÖµ: 0 Ê§°Ü
 458                                  1 ³É¹¦
 459          *****************************************/
 460          
 461          uchar ReadFuntionCard(uchar chOffset)
 462          {       
 463   1              uchar xdata temp[16];
 464   1              if(MI_RD_OK != readDataFromIc(newkey,SECTION_0 + chOffset,temp))
 465   1                      return Do_False;
 466   1      
 467   1              memcpy(maincmd+2,temp,11);
 468   1              if(MI_RD_OK != readDataFromIc(newkey,SECTION_1 + chOffset,temp))
 469   1                      return Do_False;
 470   1      
 471   1              memcpy(maincmd + 13,temp,12);
 472   1              if(MI_RD_OK != readDataFromIc(newkey,SECTION_2 + chOffset,temp))
 473   1                      return Do_False;
 474   1      
 475   1              memcpy(maincmd + 25,temp,2);
 476   1              if(MI_RD_OK != readDataFromIc(newkey,SECTION_3 + chOffset,temp))
 477   1                      return Do_False;
 478   1      
 479   1              memcpy(maincmd + 27,temp,1);
 480   1              if(MI_RD_OK != readDataFromIc(newkey,SECTION_4 + chOffset,temp))
 481   1                      return Do_False;
 482   1      
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 9   

 483   1              memcpy(maincmd + 28,temp,16);
 484   1              if(MI_RD_OK != readDataFromIc(newkey,SECTION_5 + chOffset,temp))
 485   1                      return Do_False;
 486   1      
 487   1              memcpy(maincmd + 44,temp,16);
 488   1              if(MI_RD_OK != readDataFromIc(newkey,SECTION_6 + chOffset,temp))
 489   1                      return Do_False;
 490   1      
 491   1              memcpy(maincmd + 60,temp,8);
 492   1              if(MI_RD_OK != readDataFromIc(newkey,SECTION_7 + chOffset,temp))
 493   1                      return Do_False;
 494   1              memcpy(maincmd + 68,temp,5);
 495   1              return Do_True;
 496   1      }
 497          
 498          
 499          /****************************************
 500          º¯Êý¹¦ÄÜ:
 501                  Ð´¹¦ÄÜ¿¨
 502          ÃèÊö:
 503          
 504          Ð´¿¨ÉÈÇø0~~~~7ÖÐµÄÊý¾Ý£¬
 505          ²¢±¨Êý¾Ý±£´æµ½maincmd ÖÐ
 506          ·µ»ØÖµ: 0 Ê§°Ü
 507                                  1 ³É¹¦
 508          *****************************************/
 509          uchar WriteFunctionCard(uchar chOffset)
 510          {
 511   1              uchar xdata temp[16];
 512   1              memset(temp, 0, 16);
 513   1              memcpy(temp,bt_data + 1,11);    
 514   1              if(writeDataToIc(newkey,SECTION_0 + chOffset,temp)  !=  MI_WR_OK)       
 515   1                      return Do_False;
 516   1              memset(temp, 0, 16);
 517   1              memcpy(temp,bt_data + 12,12);
 518   1              if(writeDataToIc(newkey,SECTION_1 + chOffset,temp)  !=  MI_WR_OK)
 519   1                      return Do_False;
 520   1              memset(temp, 0, 16);
 521   1              memcpy(temp,bt_data + 24,2);
 522   1              if(writeDataToIc(newkey,SECTION_2 + chOffset,temp)  !=  MI_WR_OK)
 523   1                      return Do_False;
 524   1              memset(temp, 0, 16);
 525   1              memcpy(temp,bt_data + 26,1);
 526   1              if(writeDataToIc(newkey,SECTION_3 + chOffset,temp)  !=  MI_WR_OK)
 527   1                      return Do_False;
 528   1              memset(temp, 0, 16);
 529   1              memcpy(temp,bt_data + 27,16);
 530   1              if(writeDataToIc(newkey,SECTION_4 + chOffset,temp)  !=  MI_WR_OK)
 531   1                      return Do_False;
 532   1              memset(temp, 0, 16);
 533   1              memcpy(temp,bt_data + 43,16);
 534   1              if(writeDataToIc(newkey,SECTION_5 + chOffset,temp)  !=  MI_WR_OK)
 535   1                      return Do_False;
 536   1              memset(temp, 0, 16);
 537   1              memcpy(temp,bt_data + 59,8);
 538   1              if(writeDataToIc(newkey,SECTION_6 + chOffset,temp)  !=  MI_WR_OK)
 539   1                      return Do_False;
 540   1              memset(temp, 0, 16);
 541   1              memcpy(temp,bt_data + 67,5);
 542   1              if(writeDataToIc(newkey,SECTION_7 + chOffset,temp)  !=  MI_WR_OK)
 543   1                      return Do_False;
 544   1              return  Do_True;
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 10  

 545   1      }
 546          
 547          uchar WriteOffsetPswCard()
 548          {
 549   1              uchar xdata temp[16] = {0};
 550   1              memcpy(temp,bt_data + 1,11);    
 551   1              if(writeDataToIc(newkey,SECTION_0,temp)  !=  MI_WR_OK)  
 552   1                      return Do_False;
 553   1              memset(temp, 0, 16);
 554   1              memcpy(temp,bt_data + 12,12);
 555   1              
 556   1              if(g_ulAgentID != 0xFFFFFFFF)
 557   1              {
 558   2                      temp[3] = (g_ulAgentID >> 0x24) & 0xFF;
 559   2                      temp[4] = (g_ulAgentID >> 0x16) & 0xFF;
 560   2                      temp[5] = (g_ulAgentID >> 0x8) & 0xFF;
 561   2                      temp[6] = g_ulAgentID & 0xFF;
 562   2              }
 563   1              
 564   1              if(writeDataToIc(newkey,SECTION_1,temp)  !=  MI_WR_OK)
 565   1                      return Do_False;
 566   1              memset(temp, 0, 16);
 567   1              memcpy(temp,bt_data + 24,2);
 568   1              if(writeDataToIc(newkey,SECTION_2,temp)  !=  MI_WR_OK)
 569   1                      return Do_False;
 570   1              memset(temp, 0, 16);
 571   1              memcpy(temp,bt_data + 26,1);
 572   1              if(writeDataToIc(newkey,SECTION_3,temp)  !=  MI_WR_OK)
 573   1                      return Do_False;
 574   1              memset(temp, 0, 16);
 575   1              memcpy(temp,bt_data + 27,16);
 576   1              if(writeDataToIc(newkey,SECTION_4,temp)  !=  MI_WR_OK)
 577   1                      return Do_False;
 578   1              memset(temp, 0, 16);
 579   1              memcpy(temp,bt_data + 43,16);
 580   1              if(writeDataToIc(newkey,SECTION_5,temp)  !=  MI_WR_OK)
 581   1                      return Do_False;
 582   1              memset(temp, 0, 16);
 583   1              memcpy(temp,bt_data + 59,8);
 584   1              if(writeDataToIc(newkey,SECTION_6,temp)  !=  MI_WR_OK)
 585   1                      return Do_False;
 586   1              memset(temp, 0, 16);
 587   1              memcpy(temp,bt_data + 67,5);
 588   1              if(writeDataToIc(newkey,SECTION_7,temp)  !=  MI_WR_OK)
 589   1                      return Do_False;
 590   1              return  Do_True;
 591   1      }
 592          
 593          ///****************************************
 594          //º¯Êý¹¦ÄÜ£º
 595          //¶Á¿¨ÉÈÇø0~~~~5ÖÐµÄÊý¾Ý£¬
 596          //²¢±¨Êý¾Ý±£´æµ½maincmd ÖÐ
 597          //·µ»ØÖµ:       0 Ê§°Ü
 598          //                      1 ³É¹¦
 599          //*****************************************/
 600          
 601          
 602          uchar ReadUserCard(unsigned char chOffset)
 603          {
 604   1              uchar xdata temp[16];
 605   1              uchar i = 0;
 606   1              memset(maincmd, 0, BUFINLEN);
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 11  

 607   1              if(MI_RD_OK  !=  readDataFromIc(newkey,SECTION_0 + chOffset,temp))
 608   1                      return Do_False;
 609   1              memcpy(maincmd + 2, temp, 11);
 610   1              if(MI_RD_OK  !=  readDataFromIc(newkey,SECTION_1 + chOffset,temp))
 611   1                      return Do_False;
 612   1              
 613   1              for(i = 2; i < 12; i++ )
 614   1                      temp[i] = temp[i] - i;
 615   1              
 616   1              memcpy(maincmd + 13, temp, 12);
 617   1              if(MI_RD_OK  !=  readDataFromIc(newkey,SECTION_2 + chOffset,temp))
 618   1                      return Do_False;
 619   1              memcpy(maincmd + 25, temp, 2);
 620   1              if(MI_RD_OK  !=  readDataFromIc(newkey,SECTION_3 + chOffset,temp))
 621   1                      return Do_False;
 622   1              memcpy(maincmd + 27, temp, 9);
 623   1              if(MI_RD_OK  !=  readDataFromIc(newkey,SECTION_4 + chOffset,temp))
 624   1                      return Do_False;
 625   1              memcpy(maincmd + 36, temp, 9);
 626   1              if(MI_RD_OK  !=  readDataFromIc(newkey,SECTION_5 + chOffset,temp))
 627   1                      return Do_False;
 628   1              memcpy(maincmd + 45, temp, 9);
 629   1              
 630   1              if(MI_RD_OK  !=  readDataFromIc(newkey,SECTION_6 + chOffset,temp))
 631   1                      return Do_False;
 632   1              memcpy(maincmd + 54, temp, 13);
 633   1              //errOkFlag = 1;
 634   1              return Do_True;
 635   1      }
 636          
 637          
 638          uchar WriteUserCard(uchar chOffset)
 639          {       
 640   1              uchar xdata temp[16];
 641   1              uchar i = 0;
 642   1              
 643   1              memcpy(temp, bt_data + 1,11);
 644   1              if(writeDataToIc(newkey,SECTION_0 + chOffset,temp) != MI_WR_OK) 
 645   1                      return Do_False;
 646   1      
 647   1              memcpy(temp,bt_data + 12,12);
 648   1      
 649   1              for(i = 2; i < 12; i++ )
 650   1                      temp[i] = temp[i] + i;
 651   1              if(writeDataToIc(newkey,SECTION_1 + chOffset,temp) != MI_WR_OK)
 652   1                      return Do_False;
 653   1      
 654   1              memcpy(temp,bt_data + 24,2);
 655   1              
 656   1              if(writeDataToIc(newkey,SECTION_2 + chOffset,temp) != MI_WR_OK)
 657   1                      return Do_False;
 658   1      
 659   1              memset(temp, 0, 16);
 660   1              memcpy(temp,bt_data + 26,9);
 661   1              if(writeDataToIc(newkey,SECTION_3 + chOffset,temp) != MI_WR_OK)
 662   1                      return Do_False;
 663   1      
 664   1              memset(temp, 0, 16);
 665   1              memcpy(temp,bt_data + 35,9);
 666   1              if(writeDataToIc(newkey,SECTION_4 + chOffset,temp) != MI_WR_OK)
 667   1                      return Do_False;
 668   1      
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 12  

 669   1              memset(temp, 0, 16);
 670   1              memcpy(temp,bt_data + 44,9);
 671   1              if(writeDataToIc(newkey,SECTION_5 + chOffset,temp) != MI_WR_OK)
 672   1                      return Do_False;
 673   1              
 674   1              memset(temp, 0, 16);
 675   1              memcpy(temp,bt_data + 53,13);
 676   1              if(writeDataToIc(newkey,SECTION_6 + chOffset,temp) != MI_WR_OK)
 677   1                      return Do_False;
 678   1              return  Do_True;
 679   1      }
 680          
 681          
 682          
 683          
 684          //uchar ReadOffset()
 685          //{
 686          //      uchar ucData = 0;
 687          //      ucData = IapReadByte(OFFSET_ADDR);
 688          //      if(ucData == 0xff)
 689          //              return 0;
 690          //      return ucData;
 691          //}
 692          
 693          //uchar WriteOffset(uchar chOffset)
 694          //{
 695          //      int i=0;
 696          //      uchar ucData = 0;
 697          //      IapEraseSector(OFFSET_ADDR);
 698          //      for(i=0; i<512; i++){
 699          //              ucData = IapReadByte(OFFSET_ADDR);
 700          //              if(ucData != 0xFF)
 701          //                      return Do_False;
 702          //      }
 703          //      IapProgramByte(OFFSET_ADDR, chOffset);
 704          //      return Do_True;
 705          //}
 706          
 707          
 708          void WriteFrcCardPsw(uchar ucOffset)
 709          {
 710   1              uchar xdata uIndexArea = 0;
 711   1              uchar xdata ucRet[3] = {0,0,0};
 712   1              uchar xdata uSection = ucOffset + SECTION_46;
 713   1              uchar xdata i = 0;
 714   1              uchar xdata iSectionCount = 3;
 715   1      
 716   1              
 717   1              GeneratePsw();
 718   1              //¼ÆËãÉÈÇøË÷Òý
 719   1              uIndexArea = CalcAreaofSection(uSection);
 720   1      
 721   1              if(g_chReversCheckFlag == DO_REVERSE)
 722   1                      iSectionCount = 8;
 723   1              
 724   1              for(i = 0; i < iSectionCount; i++)
 725   1                      writePassword(cardkey, uIndexArea + i, card_new_key);
 726   1      }
 727          
 728          
 729          
 730          void ClearFrcCardPsw(uchar ucOffset)
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 13  

 731          {
 732   1              uchar xdata uIndexArea = 0;
 733   1              uchar xdata uSection = ucOffset + SECTION_46;
 734   1              uchar xdata i = 0;
 735   1              uchar xdata ucPsw[16] = {0xff,0xff,0xff,0xff,0xff,0xff,0xFF,0x07,0x80,0x69,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}
             -;
 736   1      
 737   1              uchar xdata ucCardSerial[4] = {0};
 738   1      
 739   1              uchar xdata ucRet = GetCardSerial(ucCardSerial, 4);;
 740   1              
 741   1              if(ucRet != Do_True)
 742   1                      return;
 743   1              
 744   1              if(cardnum[0] == ucCardSerial[0] 
 745   1                      && cardnum[1] == ucCardSerial[1] 
 746   1                      && cardnum[2] == ucCardSerial[2] 
 747   1                      && cardnum[3] == ucCardSerial[3] )
 748   1                      return; 
 749   1      
 750   1              
 751   1              //¼ÆËãÉÈÇøË÷Òý
 752   1              uIndexArea = CalcAreaofSection(uSection);
 753   1              
 754   1              for(i = 0; i < 3; i++)
 755   1              {
 756   2                      writePassword(cardkey, uIndexArea + i, ucPsw);
 757   2              }
 758   1              
 759   1              memcpy(cardnum, ucCardSerial, 4);
 760   1      
 761   1              
 762   1              Sounds(1);
 763   1      }
 764          
 765          
 766          unsigned char WriteProductCode(uchar ucOffset)
 767          {
 768   1              uchar xdata ucRet = MI_ERR;     
 769   1              uchar xdata uIndexArea = 0;
 770   1              
 771   1              uchar xdata chProductCode[16]={0x01, 0x02, 0x03, 0x04, 0x05, 
 772   1                                                                                              0x06, 0x07, 0x08, 0x09, 0x10, 0x11, 
 773   1                                                                                              0x12, 0x13, 0x17, 0x15, 0x16};
 774   1              uchar xdata ucCardSerial[4] = {0};
 775   1              uchar xdata i = 0;
 776   1      
 777   1              ucRet = GetCardSerial(ucCardSerial, 4);
 778   1              
 779   1              if(ucRet != Do_True)
 780   1                      return Do_False;
 781   1              
 782   1              if(cardnum[0] == ucCardSerial[0] 
 783   1                      && cardnum[1] == ucCardSerial[1] 
 784   1                      && cardnum[2] == ucCardSerial[2] 
 785   1                      && cardnum[3] == ucCardSerial[3] )
 786   1                      return Do_True; 
 787   1              
 788   1              
 789   1              if(g_chPasswordFlag == DO_PASSWORD)
 790   1                      WriteFrcCardPsw(ucOffset);      
 791   1              
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 14  

 792   1              //¼ÆËãÉú²úÊý¾Ý
 793   1              chProductCode[14] = ucCardSerial[2];
 794   1              chProductCode[15] = ucCardSerial[3];
 795   1              
 796   1              chProductCode[4] = 0xA0;
 797   1      
 798   1              chProductCode[5] = ucCardSerial[0];
 799   1              chProductCode[6] = ucCardSerial[1];
 800   1              chProductCode[7] = ucCardSerial[2];
 801   1              chProductCode[8] = ucCardSerial[3];
 802   1              //Ð´Éú²úÊýÖµ
 803   1              //ucRet = writeDataToIc(card_new_key, SECTION_46 + ucOffset, chProductCode);
 804   1              //Ê¹ÓÃÐÂÃÜÂëÐ£Ñé
 805   1              if(g_chPasswordFlag == DO_PASSWORD)
 806   1                      ucRet = writeDataToIc(card_new_key, SECTION_46 + ucOffset, chProductCode);
 807   1              else
 808   1                      ucRet = writeDataToIc(cardkey, SECTION_46 + ucOffset, chProductCode);
 809   1              
 810   1              if(ucRet == MI_WR_OK)
 811   1              {       
 812   2                      memcpy(cardnum, ucCardSerial, 4);
 813   2      
 814   2                      Sounds(1);
 815   2                      
 816   2                      maincmd[0] = 0x01;
 817   2                      maincmd[1] = 0x10;
 818   2                      Make(IC_CMD_PRODUCT, 4,maincmd);
 819   2                      Send(maincmd, 9);
 820   2                                      
 821   2                      return Do_True;
 822   2              }
 823   1              
 824   1              Sounds(2);
 825   1              return Do_False;
 826   1      }
 827          
 828          
 829          unsigned char WriteAgentIDToCard(uchar ucOffset)
 830          {
 831   1              uchar ucRet = MI_ERR;   
 832   1              uchar xdata ucCardSerial[4] = {0};
 833   1              unsigned char xdata temp[16]={0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF
             -F, 0xFF, 0xFF, 0xFF};
 834   1      
 835   1              if(MI_RD_OK  !=  readDataFromIc(newkey,SECTION_46 + ucOffset,temp))
 836   1                      //return Do_False;
 837   1                      return 3;
 838   1              
 839   1              ucRet = GetCardSerial(ucCardSerial, 4);                                 //»ñÈ¡¿¨µÄ¿¨ºÅ
 840   1              
 841   1              if(ucRet != Do_True)
 842   1                      //return Do_False;      
 843   1                      return 4;
 844   1              
 845   1              temp[0] = (g_ulAgentID >> 24 ) & 0xFF;
 846   1              temp[1] = (g_ulAgentID >> 16 ) & 0xFF;
 847   1              temp[2] = (g_ulAgentID >> 8 ) & 0xFF;
 848   1              temp[3] = g_ulAgentID  & 0xFF;
 849   1              
 850   1                      
 851   1              temp[4] = 0xA0;
 852   1              
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 15  

 853   1              temp[5] = ucCardSerial[0];
 854   1              temp[6] = ucCardSerial[1];
 855   1              temp[7] = ucCardSerial[2];
 856   1              temp[8] = ucCardSerial[3];
 857   1              
 858   1              //Ð´Éú²úÊýÖµ
 859   1              ucRet = writeDataToIc(newkey, SECTION_46 + ucOffset, temp);
 860   1              
 861   1              if(ucRet != MI_WR_OK)
 862   1                      //return Do_False;
 863   1                      return 5;
 864   1              
 865   1              return Do_True;
 866   1      }
 867          
 868          
 869          //uchar GetVersion()
 870          //{
 871          //      uchar ucRet = MI_ERR;
 872          //      memset(cardknum, 0, 16);
 873          //      //¶ÁÉú²úÊýÖµ
 874          //      ucRet = readDataFromIc(newkey, SECTION_46, cardknum);
 875          //      
 876          //      if(ucRet != MI_RD_OK)
 877          //              return 0;
 878          //      
 879          //      return cardknum[4];
 880          //}
 881          
 882          //uchar WriteSerial(uchar ucOffset)
 883          //{
 884          //      uchar xdata ucRet = 0;
 885          //      uchar xdata ucCardSerial[4];
 886          //      uchar xdata ucTemp[16];
 887          
 888          //      ucRet = readDataFromIc(newkey, SECTION_46 + ucOffset, ucTemp);
 889          //      if(MI_RD_OK != ucRet)
 890          //              return Do_False;
 891          //              
 892          //      ucRet = PcdAnticoll(ucCardSerial);                                      //»ñÈ¡¿¨µÄ¿¨ºÅ
 893          //      
 894          //      if(ucRet != MI_OK)
 895          //              return Do_False;        
 896          //              
 897          //      ucTemp[4] = 0xA0;
 898          //      
 899          //      ucTemp[5] = ucCardSerial[0];
 900          //      ucTemp[6] = ucCardSerial[1];
 901          //      ucTemp[7] = ucCardSerial[2];
 902          //      ucTemp[8] = ucCardSerial[3];
 903          //      //Ð´Éú²úÊýÖµ
 904          //      ucRet = writeDataToIc(newkey, SECTION_46 + ucOffset, ucTemp);
 905          //      
 906          //      if(ucRet == MI_WR_OK)
 907          //              return Do_True;
 908          //      return Do_False;
 909          //}
 910          
 911          // Ð£ÑéÉú²úÂë
 912          unsigned char VerifyProduceCode(uchar ucOffset)
 913          {
 914   1              uchar ucRet = MI_RD_OK;
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 16  

 915   1              char cRet = MI_OK;
 916   1      
 917   1      //      cRet = PcdRequest(0x52, cardtyp);                               //Ñ°¿¨
 918   1      //      if(cRet != MI_OK)
 919   1      //      {
 920   1      //              cRet = PcdRequest(0x52, cardtyp);
 921   1      //              if(cRet != MI_OK)
 922   1      //                      return 3;
 923   1      //      }
 924   1      //      
 925   1      //      cRet = PcdAnticoll(cardnum);                                    //»ñÈ¡¿¨µÄ¿¨ºÅ
 926   1      
 927   1              cRet = GetCardSerial(cardnum ,4);
 928   1              
 929   1              if(cRet != Do_True)
 930   1                      return 4;
 931   1              
 932   1              memset(cardknum, 0, 16);
 933   1              //¶ÁÉú²úÊýÖµ
 934   1              ucRet = readDataFromIc(newkey, SECTION_46 + ucOffset, cardknum);
 935   1              
 936   1              if(ucRet != MI_RD_OK)
 937   1                      return 5;
 938   1              
 939   1              if(cardknum[14] == cardnum[2] 
 940   1                      && cardknum[15] == cardnum[3])
 941   1                      return Do_True;
 942   1              //Sounds(3);
 943   1      
 944   1              memcpy(maincmd, cardknum, 16);
 945   1              maincmd[16] = ucOffset;
 946   1                      
 947   1              return 6;
 948   1      }
 949          
 950          
 951          unsigned char ReadInterParam(uchar* pBuf)
 952          {       
 953   1              unsigned char xdata temp[32];
 954   1              if(MI_RD_OK  !=  readDataFromIc(newkey,SECTION_16,temp))        
 955   1                      return Do_False;
 956   1              memcpy(pBuf, temp, 16);
 957   1              
 958   1              if(MI_RD_OK  !=  readDataFromIc(newkey,SECTION_16 + 1,temp))    
 959   1                      return Do_False;
 960   1              
 961   1              memcpy(pBuf + 16, temp, 16);
 962   1              
 963   1              return Do_True;
 964   1      }
 965          
 966          
 967          //unsigned char RecordInterParam(uchar chOffset)
 968          //{     
 969          //      unsigned char xdata temp[16];
 970          //      unsigned char xdata tmData[7];
 971          //      //Êý¾ÝÆ«ÒÆÁ¿
 972          //      temp[0] = chOffset;
 973          //      //ÆôÓÃ´úÀíÉÌ¼ìÑé
 974          //      temp[1] = g_ucAgentVerifyFlag;
 975          
 976          //      //´úÀíÉÌID
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 17  

 977          //      temp[2] = (g_ulAgentID >> 24) & 0xFF;
 978          //      temp[3] = (g_ulAgentID >> 16) & 0xFF;
 979          //      temp[4] = (g_ulAgentID >> 8) & 0xFF;
 980          //      temp[5] = g_ulAgentID & 0xFF;
 981          
 982          //      //µçÌÝºÅ
 983          //      temp[6] = GetElevatorID();
 984          //      //µçÌÝÊ±¼ä
 985          //      readtime(tmData);
 986          //      temp[7] = tmData[0];
 987          //      temp[8] = tmData[1];
 988          //      temp[9] = tmData[2];
 989          //      temp[10] = tmData[3];
 990          //      temp[11] = tmData[4];
 991          //      temp[12] = tmData[5];
 992          //      temp[13] = tmData[6];
 993          //      temp[14] = tmData[7];
 994          //      
 995          //      if(writeDataToIc(card_new_key,SECTION_0 + chOffset + 1,temp) != MI_WR_OK)       
 996          //              return Do_False;
 997          
 998          //      return  Do_True;
 999          //}
1000          
1001          
1002          //void DeodeFrcCard(void)
1003          //{
1004          
1005          //}
1006          
1007          /****************************************
1008          º¯Êý¹¦ÄÜ£º½âÎö´Ó´®¿Ú½ÓÊÕµ½µÄÊý¾Ý
1009          
1010          *****************************************/
1011          void ScanCommand()
1012          {
1013   1              uchar i=0,j=0;
1014   1              uchar errOkFlag=0;
1015   1              uchar ErrAgentCard = 0;
1016   1              uchar ErrWriteSerial = Do_False; 
1017   1              uchar ucPswFlag = DIS_PASSWORD;
1018   1              if(1 != GetCommand(BT_UART,&bufino,bufini))
1019   1              {
1020   2                      return;
1021   2              }
1022   1              
1023   1              switch(g_chPackageFlag)
1024   1              {
1025   2              case(IC_CMD_WRITE):         //Ð´
1026   2                      if(bt_data[0] == WRITE)
1027   2                      {
1028   3                              j=0;
1029   3                              maincmd[0]=0;
1030   3                              for(i=0;i<16;i++)
1031   3                              {
1032   4                                      maincmd[i+1]=0;
1033   4                                      if(writePassword(cardkey,i,newkey)!=MI_WR_OK)
1034   4                                      {
1035   5                                              maincmd[i + 1]=1;
1036   5                                              maincmd[0]=1;
1037   5                                      }
1038   4                              }
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 18  

1039   3                              Make(1,19,maincmd);
1040   3                              Send(maincmd,24);       
1041   3                      }
1042   2                      break;
1043   2              case(IC_CMD_READ): 
1044   2              
1045   2                      if(g_chPasswordFlag == DO_PASSWORD)
1046   2                              GeneratePsw();
1047   2                      for(i=0;i<47;i++)
1048   2                      {
1049   3                              if(MI_RD_OK == readDataFromIc(newkey,i,cardknum))
1050   3                              {       
1051   4                                      Send(cardknum,16);
1052   4                              } 
1053   3                      }
1054   2                      if(g_chPasswordFlag == DO_PASSWORD)
1055   2                              RecoverPsw();
1056   2                              
1057   2                      break;
1058   2              case(IC_CMD_CUSTOMER):    //ÉÏÎ»»úÐ´ÒµÖ÷¿¨ÐÅÏ¢
1059   2                      errOkFlag=0;
1060   2                      if(bt_data[0] == READ)
1061   2                      {
1062   3                      
1063   3                              if(g_chPasswordFlag == DO_PASSWORD)
1064   3                                      GeneratePsw();
1065   3                              //¶ÁÓÃ»§Êý¾Ý
1066   3                              errOkFlag = ReadUserCard(g_chOffsetSecton);     
1067   3                              
1068   3                              if(g_chPasswordFlag == DO_PASSWORD)
1069   3                                      RecoverPsw();
1070   3                              
1071   3                              MakeResult(errOkFlag);                  
1072   3                              maincmd[1] = READ;
1073   3                              Make(IC_CMD_CUSTOMER,66,maincmd);
1074   3                              Send(maincmd,71); 
1075   3                      }
1076   2                      
1077   2                      else if(bt_data[0] == WRITE)
1078   2                      {       
1079   3                              if(g_chVerifyProduceFlag == DO_VERIFY)
1080   3                              {
1081   4                                      
1082   4                                      if(g_chPasswordFlag == DO_PASSWORD)
1083   4                                              GeneratePsw();
1084   4                                      
1085   4                                      maincmd[2] = VerifyProduceCode(g_chOffsetSecton);
1086   4                                      
1087   4                                      if(g_chPasswordFlag == DO_PASSWORD)
1088   4                                              RecoverPsw();
1089   4                                      
1090   4                                      if(Do_True != maincmd[2])
1091   4                                      {
1092   5                                              maincmd[0] = g_chVerifyProduceFlag;
1093   5                                              maincmd[1] = WRITE;
1094   5      
1095   5                                              maincmd[3] = 0xFA;
1096   5                                              maincmd[4] = 0xFA;
1097   5                                              maincmd[5] = g_chOffsetSecton;
1098   5                                              
1099   5                                              Make(IC_CMD_CUSTOMER, 7, maincmd);
1100   5                                              Send(maincmd, 12);
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 19  

1101   5                                              Sounds(2);
1102   5                                              return;
1103   5                                      }
1104   4                              }
1105   3                              
1106   3                              //¹¹½¨ÃÜÂë
1107   3                              if(g_chPasswordFlag == DO_PASSWORD)
1108   3                                      GeneratePsw();
1109   3      
1110   3                              //Ð´ÓÃ»§Êý¾Ý    
1111   3                              errOkFlag = WriteUserCard(g_chOffsetSecton);                    
1112   3                              ErrAgentCard = WriteAgentIDToCard(g_chOffsetSecton);
1113   3                              //ErrWriteSerial = WriteSerial(g_chOffsetSecton);
1114   3                              
1115   3                              //»Ö¸´ÃÜÂë
1116   3                              if(g_chPasswordFlag == DO_PASSWORD)
1117   3                                      RecoverPsw();
1118   3                              
1119   3                              MakeResult(errOkFlag);
1120   3                              maincmd[1] = WRITE;
1121   3                              maincmd[2] = ErrAgentCard;
1122   3                              maincmd[3] = ErrWriteSerial;
1123   3                              maincmd[4] = g_chOffsetSecton;
1124   3                              
1125   3                              Make(IC_CMD_CUSTOMER, 7, maincmd);
1126   3                              Send(maincmd, 12);
1127   3                      }
1128   2                      break;          
1129   2              case(IC_CMD_MANAGER):     //ÉÏÎ»»ú¶ÁÐ´¹ÜÀíÔ±¿¨
1130   2                      errOkFlag=0;
1131   2                      //¶Á¹ÜÀíÔ±¿¨
1132   2                      if(bt_data[0] == READ)
1133   2                      {
1134   3                              if(g_chPasswordFlag == DO_PASSWORD)
1135   3                                      GeneratePsw();
1136   3      
1137   3                              errOkFlag = ReadUserCard(g_chOffsetSecton);
1138   3      
1139   3                              if(g_chPasswordFlag == DO_PASSWORD)
1140   3                                      RecoverPsw();
1141   3                              
1142   3                              MakeResult(errOkFlag);
1143   3                              maincmd[1] = READ;
1144   3                              Make(IC_CMD_MANAGER, 66, maincmd);
1145   3                              Send(maincmd,71); 
1146   3                      }
1147   2                      //Ð´¹ÜÀíÔ±¿¨
1148   2                      else if(bt_data[0] == WRITE)
1149   2                      {
1150   3                              if(g_chVerifyProduceFlag == DO_VERIFY)
1151   3                              {
1152   4                                      
1153   4                                      if(g_chPasswordFlag == DO_PASSWORD)
1154   4                                              GeneratePsw();
1155   4                                      
1156   4                                      maincmd[2] = VerifyProduceCode(g_chOffsetSecton);
1157   4                                      
1158   4                                      if(g_chPasswordFlag == DO_PASSWORD)
1159   4                                              RecoverPsw();
1160   4                                      
1161   4                                      if(Do_True != maincmd[2])
1162   4                                      {
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 20  

1163   5                                              maincmd[0] = g_chVerifyProduceFlag;
1164   5                                              maincmd[1] = WRITE;
1165   5      
1166   5                                              maincmd[3] = 0xFA;
1167   5                                              maincmd[4] = 0xFA;
1168   5                                              
1169   5                                              Make(IC_CMD_MANAGER, 7, maincmd);
1170   5                                              Send(maincmd, 12);
1171   5                                              Sounds(2);
1172   5                                              return;
1173   5                                      }
1174   4                              }
1175   3                      
1176   3                              //¹¹½¨ÃÜÂë
1177   3                              if(g_chPasswordFlag == DO_PASSWORD)
1178   3                                      GeneratePsw();
1179   3                              
1180   3                              errOkFlag = WriteUserCard(g_chOffsetSecton);
1181   3                              ErrAgentCard = WriteAgentIDToCard(g_chOffsetSecton);
1182   3                              //ErrWriteSerial = WriteSerial(g_chOffsetSecton);
1183   3                              
1184   3                              //»Ö¸´ÃÜÂë
1185   3                              if(g_chPasswordFlag == DO_PASSWORD)
1186   3                                      RecoverPsw();
1187   3      
1188   3                              MakeResult(errOkFlag);
1189   3                              maincmd[1] = WRITE;
1190   3                              maincmd[2] = ErrAgentCard;
1191   3                              maincmd[3] = ErrWriteSerial;
1192   3                              Make(IC_CMD_MANAGER, 6, maincmd);
1193   3                              Send(maincmd, 11);
1194   3                      }               
1195   2                      break;
1196   2              case(IC_CMD_FUNC):        //ÉÏÎ»»ú¶ÁÐ´¹¦ÄÜ¿¨
1197   2                      errOkFlag=0;
1198   2                      //¶Á¹¦ÄÜ¿¨
1199   2                      if(bt_data[0] == READ)
1200   2                      {
1201   3                              errOkFlag = ReadFuntionCard(g_chOffsetSecton);
1202   3                              MakeResult(errOkFlag);
1203   3                              maincmd[1] = READ;
1204   3                              Make(IC_CMD_FUNC,75,maincmd);
1205   3                              Send(maincmd,80);
1206   3                              
1207   3                      }
1208   2                      //Ð´¹¦ÄÜ¿¨
1209   2                      else if(bt_data[0] == WRITE)
1210   2                      {
1211   3                              if(bt_data[6] == FUNC_TYPE_OFFSET)
1212   3                              {                               
1213   4                                      RecoverPsw();                           
1214   4                                      
1215   4                                      errOkFlag = WriteOffsetPswCard();                       
1216   4                                      ErrAgentCard = WriteAgentIDToCard(0);
1217   4                                      //ErrWriteSerial = WriteSerial(0);
1218   4                                              
1219   4                                      if(g_chPasswordFlag == DO_PASSWORD)
1220   4                                              GeneratePsw();                          
1221   4                              }
1222   3                              else if(bt_data[6] == FUNC_TYPE_Check)
1223   3                              {       
1224   4                                      RecoverPsw();
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 21  

1225   4                                                                      
1226   4                                      errOkFlag = WriteFunctionCard(g_chOffsetSecton);                        
1227   4                                      ErrAgentCard = WriteAgentIDToCard(g_chOffsetSecton);
1228   4                                      
1229   4                                      if(g_chPasswordFlag == DO_PASSWORD)
1230   4                                              GeneratePsw();                          
1231   4                              }
1232   3                              else
1233   3                              {                       
1234   4                                      //¹¹½¨ÃÜÂë      
1235   4                                      if(g_chPasswordFlag == DO_PASSWORD)
1236   4                                              GeneratePsw();
1237   4                                      
1238   4                                      errOkFlag = WriteFunctionCard(g_chOffsetSecton);                        
1239   4                                      ErrAgentCard = WriteAgentIDToCard(g_chOffsetSecton);
1240   4                                      
1241   4                                      //»Ö¸´ÃÜÂë
1242   4                                      if(g_chPasswordFlag == DO_PASSWORD)
1243   4                                              RecoverPsw();   
1244   4                              }
1245   3                              
1246   3                              MakeResult(errOkFlag);
1247   3                              maincmd[1] = WRITE;
1248   3                              maincmd[2] = ErrAgentCard;
1249   3                              maincmd[3] = ErrWriteSerial;
1250   3                              Make(IC_CMD_FUNC,5,maincmd);
1251   3                              Send(maincmd,10);
1252   3                      }                               
1253   2                      break;
1254   2              case(IC_CMD_MODIFY_TIME):
1255   2                      break;
1256   2              case(IC_CMD_GET_TIME):
1257   2                      break;
1258   2              case(IC_CMD_AGENT):
1259   2                      errOkFlag = 0;
1260   2                      if(bt_data[0] == READ)
1261   2                      {
1262   3                              g_ulAgentID = ReadAgentID();
1263   3                              MakeResult(Do_True);
1264   3                              maincmd[1] = READ;
1265   3                              maincmd[2] = (g_ulAgentID >> 24) & 0xff;
1266   3                              maincmd[3] = (g_ulAgentID >> 16) & 0xff;
1267   3                              maincmd[4] = (g_ulAgentID >> 8) & 0xff;
1268   3                              maincmd[5] = g_ulAgentID  & 0xff;       
1269   3                              maincmd[6] = g_chProduceFlag;
1270   3                              maincmd[7] = g_chReversCheckFlag;               
1271   3                              Make(IC_CMD_AGENT, 10, maincmd);
1272   3                              Send(maincmd, 15);
1273   3                      }               
1274   2                      if(bt_data[0] == WRITE)//Ð´
1275   2                      {
1276   3                              chAgentIDBuf[0]  = bt_data[1];
1277   3                              chAgentIDBuf[1]  = bt_data[2];
1278   3                              chAgentIDBuf[2]  = bt_data[3];
1279   3                              chAgentIDBuf[3]  = bt_data[4];
1280   3                              
1281   3                              //errOkFlag = WriteAgentID(chAgentIDBuf);
1282   3                              g_ulAgentID = ReadAgentID();
1283   3                              //ErrWriteSerial = WriteSerial(g_chOffsetSecton);
1284   3                              MakeResult(errOkFlag);
1285   3                              maincmd[0] = Do_True;                   
1286   3                              maincmd[1] = WRITE;
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 22  

1287   3                              maincmd[2] = (g_ulAgentID >> 24) & 0xff;
1288   3                              maincmd[3] = (g_ulAgentID >> 16) & 0xff;
1289   3                              maincmd[4] = (g_ulAgentID >> 8) & 0xff;
1290   3                              maincmd[5] = g_ulAgentID  & 0xff;
1291   3                              maincmd[6] = ErrWriteSerial;                                            
1292   3      
1293   3                              Make(IC_CMD_AGENT,9,maincmd);
1294   3                              Send(maincmd,14);
1295   3                      }
1296   2                      break;
1297   2              case(IC_CMD_PRODUCT):
1298   2                      maincmd[0] = Do_False;
1299   2                      if(bt_data[0] == START_PRODUCE_CMD)
1300   2                      {
1301   3                              g_chProduceFlag = bt_data[1] + bt_data[2];      
1302   3                              MakeResult(Do_True);
1303   3                              if(0xFF == g_chProduceFlag)
1304   3                                      Sounds(2);
1305   3                              else if(0xAA == g_chProduceFlag)
1306   3                              {
1307   4                                      Sounds(1);
1308   4                                      delay_10ms(1000);
1309   4                                      delay_10ms(1000);
1310   4                                      delay_10ms(1000);
1311   4                                      delay_10ms(1000);
1312   4                                      Sounds(1);                              
1313   4                              }
1314   3                              maincmd[1] = g_chProduceFlag;
1315   3                              maincmd[2] = g_chProduceFlag;
1316   3                              Make(IC_CMD_PRODUCT, 5, maincmd);
1317   3                              Send(maincmd, 10);
1318   3                      }
1319   2                      else if(bt_data[0] == STOP_PRODUCE_CMD)
1320   2                      {
1321   3                              g_chProduceFlag = 0x00;
1322   3                              maincmd[0] = Do_True;
1323   3                              maincmd[1] = 0;
1324   3                              maincmd[2] = 0;
1325   3                              Sounds(1);
1326   3                              Make(IC_CMD_PRODUCT, 5, maincmd);
1327   3                              Send(maincmd, 10);
1328   3                      }
1329   2                      else if(bt_data[0] == ENABLE_PRODUCE_VERITY)
1330   2                      {
1331   3                              maincmd[0] = WriteVerifyProduceFlag(0x01);
1332   3                              maincmd[1] = 0;
1333   3                              maincmd[2] = 0;
1334   3                              g_chVerifyProduceFlag = DO_VERIFY;
1335   3                              Sounds(1);
1336   3                              Make(IC_CMD_PRODUCT, 5, maincmd);
1337   3                              Send(maincmd, 10);
1338   3                      }
1339   2                      else if(bt_data[0] == DISABLE_PRODUCE_VERITY)
1340   2                      {
1341   3                              maincmd[0] = WriteVerifyProduceFlag(0xFF);
1342   3                              maincmd[1] = 0;
1343   3                              maincmd[2] = 0;
1344   3                              g_chVerifyProduceFlag = DIS_VERIFY;
1345   3                              Sounds(1);
1346   3                              Make(IC_CMD_PRODUCT, 5, maincmd);
1347   3                              Send(maincmd, 10);
1348   3                      }
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 23  

1349   2                      else if(bt_data[0] == WRITE_PRODUCE_PSW)
1350   2                      {
1351   3                              memcpy(Password_Data, bt_data + 1, 4);
1352   3                              
1353   3                              maincmd[0] = WRITE_PRODUCE_PSW;
1354   3                              //maincmd[1] = WriteSectionPsw(Password_Data);
1355   3                              memcpy(maincmd + 2, Password_Data, 4);
1356   3                              ReadSectionPsw(Password_Data);
1357   3                              memcpy(maincmd + 6, Password_Data, 4);
1358   3                              Sounds(1);
1359   3                              Make(IC_CMD_PRODUCT, 12, maincmd);
1360   3                              Send(maincmd, 17);
1361   3                      }               
1362   2                      else if(bt_data[0] == READ_PRODUCE_PSW)
1363   2                      {
1364   3                              maincmd[0] = READ_PRODUCE_PSW;
1365   3                              ReadSectionPsw(Password_Data);          
1366   3                              memcpy(maincmd + 1, Password_Data, 4);
1367   3                              maincmd[5] = g_chPasswordFlag;
1368   3                              Sounds(1);
1369   3                              Make(IC_CMD_PRODUCT, 8, maincmd);
1370   3                              Send(maincmd, 13);
1371   3                      }
1372   2                      break;
1373   2              case(IC_CMD_OFFSET):
1374   2                      errOkFlag = 0;
1375   2                      if(bt_data[0] == READ)
1376   2                      {  
1377   3                              maincmd[0] = TRUE;
1378   3                              maincmd[1] = READ;
1379   3                              maincmd[2] = ReadOffset();
1380   3                              
1381   3                              Make(IC_CMD_OFFSET,5,maincmd);
1382   3                              Send(maincmd,10);
1383   3                      }
1384   2                      if(bt_data[0] == WRITE)//Ð´
1385   2                      {                                       
1386   3                              memcpy(maincmd, bt_data + 1, 14);
1387   3                              WriteFlagDatas(maincmd,14);
1388   3                                                      
1389   3      //                      WriteOffset(bt_data[1]);
1390   3      //                      WritePasswordFlag(bt_data[2]);
1391   3      //                      WriteSectionPsw(bt_data + 4);   
1392   3      //                      WriteAgentID(bt_data + 8);
1393   3      //                      ErrWriteSerial = WriteSerial(g_chOffsetSecton); 
1394   3                              
1395   3                              MakeResult(Do_True);
1396   3                              maincmd[1] = WRITE;
1397   3                              maincmd[2] = ReadOffset();
1398   3                              maincmd[3] = ErrWriteSerial;
1399   3                              
1400   3                              Make(IC_CMD_OFFSET,6,maincmd);
1401   3                              Send(maincmd,11);
1402   3                              
1403   3                              //Sounds(g_chOffsetSecton);
1404   3                      }               
1405   2                      Sounds(1);
1406   2                      break;
1407   2              case(IC_CMD_GETSERIAL):
1408   2                      errOkFlag=0;
1409   2                      memset(maincmd, 0, 10);
1410   2                      errOkFlag = GetCardSerial(bt_data, 4);
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 24  

1411   2                      MakeResult(errOkFlag);
1412   2                      maincmd[1] = IC_CMD_GETSERIAL;          
1413   2                      memcpy(maincmd + 2, bt_data, 4);
1414   2                      Make(IC_CMD_GETSERIAL, 8, maincmd);
1415   2                      Send(maincmd, 13);
1416   2                      break;
1417   2                      
1418   2              case(IC_CMD_GET_CHECK):
1419   2                      errOkFlag=0;
1420   2                      memset(maincmd, 0, BUFINLEN);
1421   2                      
1422   2                      if(g_chPasswordFlag == DO_PASSWORD)
1423   2                              RecoverPsw();
1424   2                      
1425   2                      errOkFlag = ReadInterParam(bt_data);
1426   2                      
1427   2                      if(g_chPasswordFlag == DO_PASSWORD)
1428   2                              GeneratePsw();
1429   2                      
1430   2                      MakeResult(errOkFlag);
1431   2                      maincmd[1] = IC_CMD_GET_CHECK;          
1432   2                      memcpy(maincmd + 2, bt_data, 32);
1433   2                      Make(IC_CMD_GET_CHECK, 34, maincmd);
1434   2                      Send(maincmd, 39);
1435   2                      break;
1436   2              
1437   2              case(IC_CMD_TEST):
1438   2                      Sounds(1);
1439   2                      if(bt_data[0] == 0x01)
1440   2                      {
1441   3                              for(i=1; i<6; i++)
1442   3                                      maincmd[i] = 0xEE;
1443   3                              maincmd[0] = Do_True;
1444   3                              Make(IC_CMD_TEST, 9,maincmd);
1445   3                              Send(maincmd, 14);
1446   3                              
1447   3                      }
1448   2                      break;          
1449   2              }
1450   1      }
1451          
1452          void Uart1(void) interrupt 4 using 2
1453          {  
1454   1              if(RI)
1455   1              {
1456   2                      SCON =SCON & 0xfe;
1457   2                      
1458   2                      bt_buf[bufini++]=SBUF;
1459   2                      
1460   2                      if (bufini>=BUFINLEN) 
1461   2                              bufini=0;
1462   2              }
1463   1              else if(TI)
1464   1              {
1465   2                      SCON =SCON & 0xFd;
1466   2                      
1467   2                      if(internal2)
1468   2                      {
1469   3                              if(!(--counter2))
1470   3                                      internal2=0; 
1471   3                              else 
1472   3                                      SBUF=*pp2++;//SBUF=XBYTE[pn++];
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 25  

1473   3                      }
1474   2              }
1475   1      }
1476          void Uart2(void) interrupt 8 using 2
1477          {  
1478   1      //      xmtime=0;
1479   1              
1480   1              if(RI2)
1481   1              {
1482   2                      S2CON =S2CON & 0xfe;
1483   2                      
1484   2                      bt_buf[bufini++]=S2BUF;
1485   2                              
1486   2                      if (bufini>=BUFINLEN) 
1487   2                              bufini=0;
1488   2              }
1489   1              else if(TI2)
1490   1              {
1491   2                      S2CON =S2CON & 0xFd;
1492   2                      
1493   2                      if(internal2)
1494   2                      {
1495   3                              if(!(--counter2))
1496   3                                      internal2=0; 
1497   3                              else 
1498   3                                      S2BUF=*pp2++;//SBUF=XBYTE[pn++];
1499   3                      }               
1500   2              }
1501   1      }
1502          //ÏµÍ³Ö÷º¯Êý
1503          void main (void)
1504          {
1505   1              unsigned int look_status_time=0;
1506   1              unsigned int test=0;
1507   1              Time_init();      //Á½¸ö¶¨Ê±Æ÷³õÊ¼»¯
1508   1              UART_init() ;
1509   1              EA=1;
1510   1              //IapProgramByte(0, 45);
1511   1              PcdReset();
1512   1              //¹Ø±ÕÌìÏß
1513   1              PcdAntennaOff();
1514   1              //´ò¿ªÌìÏß
1515   1              PcdAntennaOn();  
1516   1              //ÉèÖÃ¹¤×÷·½Ê½
1517   1              M500PcdConfigISOType( 'A' );
1518   1              //halRfReceivePacket(RxBuf, &leng) ;
1519   1              LEDON
1520   1              
1521   1              Delay1();
1522   1              P0M1&=0XDF;
1523   1              P0M0|=0X20;
1524   1              
1525   1              Sounds(1);      
1526   1              g_chOffsetSecton = ReadOffset();
1527   1      
1528   1              g_chVerifyProduceFlag = ReadVerifyProduceFlag();
1529   1      
1530   1              g_ulAgentID = ReadAgentID();
1531   1      
1532   1              ReadSectionPsw(Password_Data);
1533   1      
1534   1              g_chPasswordFlag = ReadPasswordFlag();
C51 COMPILER V9.53.0.0   MAIN                                                              07/16/2017 23:21:50 PAGE 26  

1535   1              g_chReversCheckFlag = ReadReverseCheckFlag();
1536   1              
1537   1              maincmd[0] = g_chOffsetSecton;
1538   1              maincmd[1] = g_chVerifyProduceFlag;
1539   1              
1540   1              maincmd[2] = (g_ulAgentID >> 24) & 0xff;
1541   1              maincmd[3] = (g_ulAgentID >> 16) & 0xff;
1542   1              maincmd[4] = (g_ulAgentID >> 8) & 0xff;
1543   1              maincmd[5] = g_ulAgentID & 0xff;
1544   1      
1545   1              maincmd[6] = Password_Data[0];
1546   1              maincmd[7] = Password_Data[1];
1547   1              maincmd[8] = Password_Data[2];
1548   1              maincmd[9] = Password_Data[3];
1549   1              
1550   1              maincmd[10] = g_chReversCheckFlag;
1551   1              
1552   1              Make(0xFC, 13, maincmd);
1553   1              Send(maincmd, 18);
1554   1              
1555   1              ReadFlagDatas(maincmd);
1556   1              Make(0xFC,18,maincmd);
1557   1              Send(maincmd,23);
1558   1                      
1559   1              if(g_chPasswordFlag == DO_PASSWORD)
1560   1              {
1561   2                      GeneratePsw();
1562   2                      
1563   2                      memcpy(maincmd,newkey,16);
1564   2                      Make(0xF9,18,maincmd);
1565   2                      Send(maincmd,23); 
1566   2              }
1567   1              
1568   1              while(TRUE)
1569   1              { 
1570   2                      if(bufini != bufino) 
1571   2                              ScanCommand();
1572   2                      
1573   2                      if(g_chProduceFlag == 0xFF)
1574   2                              WriteProductCode(g_chOffsetSecton);             
1575   2                      
1576   2                      else if(g_chProduceFlag == 0xAA)
1577   2                              ClearFrcCardPsw(g_chOffsetSecton);      
1578   2              }
1579   1      }
1580          
1581          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7612    ----
   CONSTANT SIZE    =     83    ----
   XDATA SIZE       =    359     284
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5      47
   IDATA SIZE       =      2    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
